<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CHAI 3D: cGenericObject Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>cGenericObject Class Reference</h1><!-- doxytag: class="cGenericObject" -->This class is the root of basically every render-able object in CHAI. It defines a reference frame (position and rotation) and virtual methods for rendering, which are overloaded by useful subclasses.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;CGenericObject.h&gt;</code>
<p>
<p>Inheritance diagram for cGenericObject:
<p><center><img src="classc_generic_object.png" usemap="#cGenericObject_map" border="0" alt=""></center>
<map name="cGenericObject_map">
<area href="classc_bitmap.html" alt="cBitmap" shape="rect" coords="150,56,290,80">
<area href="classc_camera.html" alt="cCamera" shape="rect" coords="150,112,290,136">
<area href="classc_generic_potential_field.html" alt="cGenericPotentialField" shape="rect" coords="150,168,290,192">
<area href="classc_generic_shader.html" alt="cGenericShader" shape="rect" coords="150,224,290,248">
<area href="classc_generic_tool.html" alt="cGenericTool" shape="rect" coords="150,280,290,304">
<area href="classc_light.html" alt="cLight" shape="rect" coords="150,336,290,360">
<area href="classc_mesh.html" alt="cMesh" shape="rect" coords="150,392,290,416">
<area href="classc_world.html" alt="cWorld" shape="rect" coords="150,448,290,472">
</map>
<a href="classc_generic_object-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#422566b11cfee02a4db559c288fedd58">cGenericObject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>.  <a href="#422566b11cfee02a4db559c288fedd58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#587289693b38360ecc66684ec94c9209">~cGenericObject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>.  <a href="#587289693b38360ecc66684ec94c9209"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f5189d2e6a0456c2d5f257ca8bdf360a">renderSceneGraph</a> (const int a_renderMode=CHAI_RENDER_MODE_RENDER_ALL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render the entire scene graph, starting from this object.  <a href="#f5189d2e6a0456c2d5f257ca8bdf360a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ac1a66d5cd30b9c5988601c81dfbe79"></a><!-- doxytag: member="cGenericObject::getParent" ref="0ac1a66d5cd30b9c5988601c81dfbe79" args="() const" -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#0ac1a66d5cd30b9c5988601c81dfbe79">getParent</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read parent of current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4732065b0fa9c9e7200b706fe8b23ddd"></a><!-- doxytag: member="cGenericObject::setPos" ref="4732065b0fa9c9e7200b706fe8b23ddd" args="(const cVector3d &amp;a_pos)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#4732065b0fa9c9e7200b706fe8b23ddd">setPos</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local position of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="509690041713dbb4d93ff29361cc74f1"></a><!-- doxytag: member="cGenericObject::setPos" ref="509690041713dbb4d93ff29361cc74f1" args="(const double a_x, const double a_y, const double a_z)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#509690041713dbb4d93ff29361cc74f1">setPos</a> (const double a_x, const double a_y, const double a_z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local position of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="465e7c823861890c247f9ad3a3e93924"></a><!-- doxytag: member="cGenericObject::getPos" ref="465e7c823861890c247f9ad3a3e93924" args="() const" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#465e7c823861890c247f9ad3a3e93924">getPos</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local position of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25afd7c5a2543df15c9ce6ad3a73b63b"></a><!-- doxytag: member="cGenericObject::getGlobalPos" ref="25afd7c5a2543df15c9ce6ad3a73b63b" args="() const" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#25afd7c5a2543df15c9ce6ad3a73b63b">getGlobalPos</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the global position of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d8389b7ae9cb1d9cd7b9952fa16ac156"></a><!-- doxytag: member="cGenericObject::setRot" ref="d8389b7ae9cb1d9cd7b9952fa16ac156" args="(const cMatrix3d &amp;a_rot)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d8389b7ae9cb1d9cd7b9952fa16ac156">setRot</a> (const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;a_rot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local rotation matrix for this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1db1451422ebc2d6c7816e931b061482"></a><!-- doxytag: member="cGenericObject::getRot" ref="1db1451422ebc2d6c7816e931b061482" args="() const" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#1db1451422ebc2d6c7816e931b061482">getRot</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local rotation matrix of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c36ec10831bf311b99b1169b1a7ec85"></a><!-- doxytag: member="cGenericObject::getGlobalRot" ref="1c36ec10831bf311b99b1169b1a7ec85" args="() const" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#1c36ec10831bf311b99b1169b1a7ec85">getGlobalRot</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the global rotation matrix of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b08a1331c6217e833acf95466799962f">translate</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_translation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate this object by a specified offset.  <a href="#b08a1331c6217e833acf95466799962f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#92df52ff262a682849a1e572393ff9b4">translate</a> (const double a_x, const double a_y, const double a_z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate this object by a specified offset.  <a href="#92df52ff262a682849a1e572393ff9b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#bba165a0395766782e2dbe7735efe8a9">rotate</a> (const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;a_rotation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate this object by multiplying with a specified rotation matrix.  <a href="#bba165a0395766782e2dbe7735efe8a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f9b82697b12cefa4a9601a45e055f8cb">rotate</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_axis, const double a_angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate this object around axis a_axis by angle a_angle (radians).  <a href="#f9b82697b12cefa4a9601a45e055f8cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ab21f63a5cf247f607158ca1e7422617">computeGlobalPositions</a> (const bool a_frameOnly=true, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_globalPos=<a class="el" href="structc_vector3d.html">cVector3d</a>(0.0, 0.0, 0.0), const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;a_globalRot=cIdentity3d())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the global position and rotation of this object and its children.  <a href="#ab21f63a5cf247f607158ca1e7422617"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#af669adcf2a807bc30b5298b6985f24f">computeGlobalCurrentObjectOnly</a> (const bool a_frameOnly=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the global position and rotation of current object only.  <a href="#af669adcf2a807bc30b5298b6985f24f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c575d5fd60c350de14aff012874cdf20">computeCollisionDetection</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointA, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointB, <a class="el" href="classc_generic_object.html">cGenericObject</a> *&amp;a_colObject, <a class="el" href="classc_triangle.html">cTriangle</a> *&amp;a_colTriangle, <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_colPoint, double &amp;a_colSquareDistance, const bool a_visibleObjectsOnly=false, const int a_proxyCall=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute collision detection using collision trees.  <a href="#c575d5fd60c350de14aff012874cdf20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c8d9678dab8af65567544d55118fd967">AdjustCollisionSegment</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointA, <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_localSegmentPointA, const <a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust collision segment for dynamic objects.  <a href="#c8d9678dab8af65567544d55118fd967"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5732cfc65122618a7857809d3cad9e06">computeForces</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_probePosition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descend through child objects to compute interaction forces for all cGenericPotentialFields.  <a href="#5732cfc65122618a7857809d3cad9e06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#532d70717dbac5a6b974d61dee5722a7">setShow</a> (const bool a_show, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide this object, optionally propagating the change to children.  <a href="#532d70717dbac5a6b974d61dee5722a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f98c2f9699524ece20e2d498a42b6696"></a><!-- doxytag: member="cGenericObject::getShow" ref="f98c2f9699524ece20e2d498a42b6696" args="() const" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f98c2f9699524ece20e2d498a42b6696">getShow</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of object (true means it's visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6c9067771330437a4906eb90e45db334">setHapticEnabled</a> (const bool a_hapticEnabled, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow this object to be felt (when visible), optionally propagating the change to children.  <a href="#6c9067771330437a4906eb90e45db334"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed933a27ad80bffb38aeee22e4909ea1"></a><!-- doxytag: member="cGenericObject::getHapticEnabled" ref="ed933a27ad80bffb38aeee22e4909ea1" args="() const" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ed933a27ad80bffb38aeee22e4909ea1">getHapticEnabled</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the haptic status of object (true means it can be felt when visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#363edb61b70cd06722a7b9d9594da1da">setShowTree</a> (const bool a_showTree, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide the child/parent tree, optionally propagating the change to children.  <a href="#363edb61b70cd06722a7b9d9594da1da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fd26146ba5f335e2373d8f56701a23a7"></a><!-- doxytag: member="cGenericObject::getShowTree" ref="fd26146ba5f335e2373d8f56701a23a7" args="() const" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#fd26146ba5f335e2373d8f56701a23a7">getShowTree</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of the tree (true means it's visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ec8f42b031fb0140633b5cb73e16094b">setTreeColor</a> (const <a class="el" href="structc_colorf.html">cColorf</a> &amp;a_treeColor, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the tree color, optionally propagating the change to children.  <a href="#ec8f42b031fb0140633b5cb73e16094b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="436925dc68fe42eb25269b943ea6183d"></a><!-- doxytag: member="cGenericObject::getTreeColor" ref="436925dc68fe42eb25269b943ea6183d" args="() const" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#436925dc68fe42eb25269b943ea6183d">getTreeColor</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the tree color. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#645192ff03d772d141a2e391fe355910">setShowFrame</a> (const bool a_showFrame, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide the reference frame arrows for this object, optionally propagating the change to children.  <a href="#645192ff03d772d141a2e391fe355910"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8ce30b90ea019105185b24e4ecdf626"></a><!-- doxytag: member="cGenericObject::getShowFrame" ref="a8ce30b90ea019105185b24e4ecdf626" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#a8ce30b90ea019105185b24e4ecdf626">getShowFrame</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of the reference frame (true means it's visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#3d1b3334e5dcb92ff585694f1b18d7f7">setShowBox</a> (const bool iShowBox, const bool iAffectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide the boundary box for this object, optionally propagating the change to children.  <a href="#3d1b3334e5dcb92ff585694f1b18d7f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d63b24c529c4b86e245e48739ca70724"></a><!-- doxytag: member="cGenericObject::getShowBox" ref="d63b24c529c4b86e245e48739ca70724" args="() const" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d63b24c529c4b86e245e48739ca70724">getShowBox</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of boundary box. (true means it's visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#36189f1d90cb10cbddb429d5789eef9f">setBoxColor</a> (const <a class="el" href="structc_colorf.html">cColorf</a> &amp;a_boxColor, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the color of boundary box for this object, optionally propagating the change to children.  <a href="#36189f1d90cb10cbddb429d5789eef9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="51c0b7072edbfb6cd5a6ac9bff1cdfa8"></a><!-- doxytag: member="cGenericObject::getBoxColor" ref="51c0b7072edbfb6cd5a6ac9bff1cdfa8" args="() const" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#51c0b7072edbfb6cd5a6ac9bff1cdfa8">getBoxColor</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the color of boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#860091e53c3913532cd1c00d55042b87">showCollisionTree</a> (const bool a_showCollisionTree, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide the collision tree for this object, optionally propagating the change to children.  <a href="#860091e53c3913532cd1c00d55042b87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#bceaa39ca365c7092d4b3932665439d8">onDisplayReset</a> (const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should get called when it's necessary to re-initialize the OpenGL context.  <a href="#bceaa39ca365c7092d4b3932665439d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ca3d6fc97084c2ab439d2486d98e23e6">finalize</a> (const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function tells children that you're not going to change their contents any more.  <a href="#ca3d6fc97084c2ab439d2486d98e23e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c6bf258cebfd460192b3a1383266ea95">unfinalize</a> (const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function tells objects that you may modify their contents.  <a href="#c6bf258cebfd460192b3a1383266ea95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c43081628c7ae8577dcb270983eea2e6">setFrameSize</a> (const double a_size=1.0, const double a_thickness=1.0, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the size of the rendered reference frame, optionally propagating the change to children.  <a href="#c43081628c7ae8577dcb270983eea2e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3bc016f7c875ecbe7584744e33222f64"></a><!-- doxytag: member="cGenericObject::getFrameSize" ref="3bc016f7c875ecbe7584744e33222f64" args="() const" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#3bc016f7c875ecbe7584744e33222f64">getFrameSize</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the size of the rendered reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1fad1f30424c4249982b56edb8f8792"></a><!-- doxytag: member="cGenericObject::getBoundaryMin" ref="e1fad1f30424c4249982b56edb8f8792" args="() const" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#e1fad1f30424c4249982b56edb8f8792">getBoundaryMin</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the minimum point of this object's boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c46c84b1e077b42c3138e13c26031d3"></a><!-- doxytag: member="cGenericObject::getBoundaryMax" ref="0c46c84b1e077b42c3138e13c26031d3" args="() const" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#0c46c84b1e077b42c3138e13c26031d3">getBoundaryMax</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the maximum point of this object's boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87ff985eb66a46f5ae44d80e5b2740e1"></a><!-- doxytag: member="cGenericObject::getBoundaryCenter" ref="87ff985eb66a46f5ae44d80e5b2740e1" args="() const" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#87ff985eb66a46f5ae44d80e5b2740e1">getBoundaryCenter</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the center of this object's boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#152b67a212d8f359ec7a24d2c8be7a33">computeBoundaryBox</a> (const bool a_includeChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-compute this object's bounding box, optionally forcing it to bound child objects.  <a href="#152b67a212d8f359ec7a24d2c8be7a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca06014fb45dd2cf7e8c71b2b8062dbf"></a><!-- doxytag: member="cGenericObject::setCollisionDetector" ref="ca06014fb45dd2cf7e8c71b2b8062dbf" args="(cGenericCollision *a_collisionDetector)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ca06014fb45dd2cf7e8c71b2b8062dbf">setCollisionDetector</a> (<a class="el" href="classc_generic_collision.html">cGenericCollision</a> *a_collisionDetector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a collision detector for current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="37f9ec5b9f01073a72caee8ded077960"></a><!-- doxytag: member="cGenericObject::getCollisionDetector" ref="37f9ec5b9f01073a72caee8ded077960" args="() const" -->
<a class="el" href="classc_generic_collision.html">cGenericCollision</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#37f9ec5b9f01073a72caee8ded077960">getCollisionDetector</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get pointer to this object's current collision detector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#22abb35355c5be8622be3cac2e6fb510">setCollisionDetectorProperties</a> (unsigned int a_displayDepth, <a class="el" href="structc_colorf.html">cColorf</a> &amp;a_color, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set collision rendering properties.  <a href="#22abb35355c5be8622be3cac2e6fb510"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#e923e09ba8708ecc49f423f0ef68fba8">deleteCollisionDetector</a> (const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete any existing collision detector and set the current cd to null (no collisions).  <a href="#e923e09ba8708ecc49f423f0ef68fba8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09f6d7d1fde9cda79b43dd9008818014"></a><!-- doxytag: member="cGenericObject::getChild" ref="09f6d7d1fde9cda79b43dd9008818014" args="(const unsigned int a_index) const " -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#09f6d7d1fde9cda79b43dd9008818014">getChild</a> (const unsigned int a_index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an object from my list of children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#84e3f5d5cd786a987c77ed19eed4c054">addChild</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an object to my list of children.  <a href="#84e3f5d5cd786a987c77ed19eed4c054"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#90e5033f96dc1e891cac79e5e56e1424">removeChild</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an object from my list of children, without deleting it.  <a href="#90e5033f96dc1e891cac79e5e56e1424"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d54d4284c0ca71d2e199080bc3559878">containsChild</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object, bool a_includeChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this object have the specified object as a child?  <a href="#d54d4284c0ca71d2e199080bc3559878"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b612f2a2121062bd70b1096bc51a6895">deleteChild</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an object from my list of children and delete it.  <a href="#b612f2a2121062bd70b1096bc51a6895"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f56e64f9db66bc82e51c44e756e13495">clearAllChildren</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all objects from my list of children, without deleting them.  <a href="#f56e64f9db66bc82e51c44e756e13495"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#a1552a230244d2119043026e03aef8f2">deleteAllChildren</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear and delete all objects from my list of children.  <a href="#a1552a230244d2119043026e03aef8f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f5b57d4b83926f1593bc051c0eda07e9"></a><!-- doxytag: member="cGenericObject::getNumChildren" ref="f5b57d4b83926f1593bc051c0eda07e9" args="()" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f5b57d4b83926f1593bc051c0eda07e9">getNumChildren</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of children on my list of children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#746f4083ff824c30a246cd01c17893a1">getNumDescendants</a> (bool a_includeCurrentObject=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return my total number of descendants, optionally including this object.  <a href="#746f4083ff824c30a246cd01c17893a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#58001a089d78289dde9adfc2403a6a62">enumerateChildren</a> (std::list&lt; <a class="el" href="classc_generic_object.html">cGenericObject</a> * &gt; &amp;a_childList, bool a_includeCurrentObject=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill this list with all of my descendants.  <a href="#58001a089d78289dde9adfc2403a6a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6642e18832667bd51ef98432e8966b85"></a><!-- doxytag: member="cGenericObject::removeFromGraph" ref="6642e18832667bd51ef98432e8966b85" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6642e18832667bd51ef98432e8966b85">removeFromGraph</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove me from my parent's CHAI scene graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#9be8abb917b1f84e5196c0213aca1617">scale</a> (const double &amp;a_scaleFactor, const bool a_includeChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale this object by a_scaleFactor (uniform scale).  <a href="#9be8abb917b1f84e5196c0213aca1617"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#8bdcfa16951b6da2f8c6f0b95d2d9500">scale</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_scaleFactors, const bool a_includeChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-uniform scale.  <a href="#8bdcfa16951b6da2f8c6f0b95d2d9500"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#001853c55875d15fc535f6806ac0b47b">setTag</a> (const int a_tag, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the tag for this object and - optionally - for my children.  <a href="#001853c55875d15fc535f6806ac0b47b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#af6da87dec3f13c00fd338ea9af1c9fc">setUserData</a> (void *a_data, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the m_userData pointer for this object and - optionally - for my children.  <a href="#af6da87dec3f13c00fd338ea9af1c9fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#8a1cce0f5d34a968da81bcb54524e8b1">setName</a> (const char *a_name, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name for this object and - optionally - for my children.  <a href="#8a1cce0f5d34a968da81bcb54524e8b1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f41a6d2c9632073a943695f8bd231ae"></a><!-- doxytag: member="cGenericObject::m_historyValid" ref="5f41a6d2c9632073a943695f8bd231ae" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5f41a6d2c9632073a943695f8bd231ae">m_historyValid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are m_lastPos and m_lastRot up-to-date? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cfe549e352ea3fd49ebd112b8d82dd6c"></a><!-- doxytag: member="cGenericObject::m_lastPos" ref="cfe549e352ea3fd49ebd112b8d82dd6c" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#cfe549e352ea3fd49ebd112b8d82dd6c">m_lastPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A previous position; exact interpretation up to user. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e02e9a6a728030ae22720ca157e9a3fe"></a><!-- doxytag: member="cGenericObject::m_lastRot" ref="e02e9a6a728030ae22720ca157e9a3fe" args="" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#e02e9a6a728030ae22720ca157e9a3fe">m_lastRot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A previous rotation; exact interpretation up to user. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9257da1a0aa43080bf706545e004c3f0"></a><!-- doxytag: member="cGenericObject::m_tag" ref="9257da1a0aa43080bf706545e004c3f0" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#9257da1a0aa43080bf706545e004c3f0">m_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An arbitrary tag, not used by CHAI. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="184b30efc8533834ab7d33cc5688b625"></a><!-- doxytag: member="cGenericObject::m_userData" ref="184b30efc8533834ab7d33cc5688b625" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#184b30efc8533834ab7d33cc5688b625">m_userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An arbitrary data pointer, not used by CHAI. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7780c5002604fde1c919b1b0b35fb65d"></a><!-- doxytag: member="cGenericObject::m_objectName" ref="7780c5002604fde1c919b1b0b35fb65d" args="[CHAI_MAX_OBJECT_NAME_LENGTH]" -->
char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#7780c5002604fde1c919b1b0b35fb65d">m_objectName</a> [CHAI_MAX_OBJECT_NAME_LENGTH]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A name for this object, automatically assigned by mesh loaders (for example). <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#7eb87a0e7dd896f081854e693e4f60d9">render</a> (const int a_renderMode=CHAI_RENDER_MODE_RENDER_ALL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render this object in OpenGL.  <a href="#7eb87a0e7dd896f081854e693e4f60d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0e5d7ce19ae357176f0f407626a80f8"></a><!-- doxytag: member="cGenericObject::updateGlobalPositions" ref="f0e5d7ce19ae357176f0f407626a80f8" args="(const bool a_frameOnly)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f0e5d7ce19ae357176f0f407626a80f8">updateGlobalPositions</a> (const bool a_frameOnly)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the m_globalPos and m_globalRot properties of any members of this object (e.g. all triangles). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d5fff8fb9e5b6ecff89b29efaed9ca1"></a><!-- doxytag: member="cGenericObject::updateBoundaryBox" ref="0d5fff8fb9e5b6ecff89b29efaed9ca1" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#0d5fff8fb9e5b6ecff89b29efaed9ca1">updateBoundaryBox</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the bounding box of this object, based on object-specific data (e.g. triangle positions). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c647d27f4e9f308dbf5db2af56fab17"></a><!-- doxytag: member="cGenericObject::scaleObject" ref="5c647d27f4e9f308dbf5db2af56fab17" args="(const cVector3d &amp;a_scaleFactors)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5c647d27f4e9f308dbf5db2af56fab17">scaleObject</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_scaleFactors)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale current object with scale factors along x, y and z. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="42ed6c65ea4f0fc7bbe4cfd5ddb0f989"></a><!-- doxytag: member="cGenericObject::m_parent" ref="42ed6c65ea4f0fc7bbe4cfd5ddb0f989" args="" -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#42ed6c65ea4f0fc7bbe4cfd5ddb0f989">m_parent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parent object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ffbf37ddc31306fe97dad8dc5e66c7d2"></a><!-- doxytag: member="cGenericObject::m_children" ref="ffbf37ddc31306fe97dad8dc5e66c7d2" args="" -->
vector&lt; <a class="el" href="classc_generic_object.html">cGenericObject</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ffbf37ddc31306fe97dad8dc5e66c7d2">m_children</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">My list of children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="995b36bda97019f7914d9253de907dfe"></a><!-- doxytag: member="cGenericObject::m_localPos" ref="995b36bda97019f7914d9253de907dfe" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#995b36bda97019f7914d9253de907dfe">m_localPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The position of this object in my parent's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="17d87fe53dc0b438bf8d1a993f6c33e3"></a><!-- doxytag: member="cGenericObject::m_globalPos" ref="17d87fe53dc0b438bf8d1a993f6c33e3" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#17d87fe53dc0b438bf8d1a993f6c33e3">m_globalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The position of this object in the world's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a7000a221c523d46dc84d7a6f4c0cd6"></a><!-- doxytag: member="cGenericObject::m_localRot" ref="9a7000a221c523d46dc84d7a6f4c0cd6" args="" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#9a7000a221c523d46dc84d7a6f4c0cd6">m_localRot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rotation matrix that rotates my reference frame into my parent's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5a08fdb16af899fb92e7be839292b097"></a><!-- doxytag: member="cGenericObject::m_globalRot" ref="5a08fdb16af899fb92e7be839292b097" args="" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5a08fdb16af899fb92e7be839292b097">m_globalRot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rotation matrix that rotates my reference frame into the world's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6bcf652fb1e4cfdccd5d7d8d5778734f"></a><!-- doxytag: member="cGenericObject::m_boundaryBoxMin" ref="6bcf652fb1e4cfdccd5d7d8d5778734f" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6bcf652fb1e4cfdccd5d7d8d5778734f">m_boundaryBoxMin</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum position of boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="149f973696bc569e4b1aa0a985bba23e"></a><!-- doxytag: member="cGenericObject::m_boundaryBoxMax" ref="149f973696bc569e4b1aa0a985bba23e" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#149f973696bc569e4b1aa0a985bba23e">m_boundaryBoxMax</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum position of boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52b37b8bb3f723987881ac0ff81d954a"></a><!-- doxytag: member="cGenericObject::m_frameSize" ref="52b37b8bb3f723987881ac0ff81d954a" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#52b37b8bb3f723987881ac0ff81d954a">m_frameSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of graphical representation of frame (X-Y-Z). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a93045f0fa3c3f271b00fbd942a95c9"></a><!-- doxytag: member="cGenericObject::m_show" ref="4a93045f0fa3c3f271b00fbd942a95c9" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#4a93045f0fa3c3f271b00fbd942a95c9">m_show</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, this object is rendered. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6e8808407cc75bf3dbee02dcadd2ae64"></a><!-- doxytag: member="cGenericObject::m_hapticEnabled" ref="6e8808407cc75bf3dbee02dcadd2ae64" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6e8808407cc75bf3dbee02dcadd2ae64">m_hapticEnabled</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IF <b>true</b>, this object can be felt. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f44c458872b98a634008a52318fae9ef"></a><!-- doxytag: member="cGenericObject::m_showFrame" ref="f44c458872b98a634008a52318fae9ef" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f44c458872b98a634008a52318fae9ef">m_showFrame</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, this object's reference frame is rendered as a set of arrows. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25c2acb8ea52ebf30ee1b9eff3ac294d"></a><!-- doxytag: member="cGenericObject::m_showBox" ref="25c2acb8ea52ebf30ee1b9eff3ac294d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#25c2acb8ea52ebf30ee1b9eff3ac294d">m_showBox</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, this object's boundary box is displayed as a set of lines. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d04599aea8b9caa56dd2335f9afc8e36"></a><!-- doxytag: member="cGenericObject::m_showTree" ref="d04599aea8b9caa56dd2335f9afc8e36" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d04599aea8b9caa56dd2335f9afc8e36">m_showTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, the skeleton of the scene graph is rendered at this node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b28ca5f27ab6accbaf7ebf22a80cba24"></a><!-- doxytag: member="cGenericObject::m_showCollisionTree" ref="b28ca5f27ab6accbaf7ebf22a80cba24" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b28ca5f27ab6accbaf7ebf22a80cba24">m_showCollisionTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, the collision tree is displayed (if available) at this node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c9749673419d6ea51ae89bd8f5df8c0"></a><!-- doxytag: member="cGenericObject::m_treeColor" ref="3c9749673419d6ea51ae89bd8f5df8c0" args="" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#3c9749673419d6ea51ae89bd8f5df8c0">m_treeColor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The color of the collision tree. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b76bfe86033c2692ecde47afc1e19997"></a><!-- doxytag: member="cGenericObject::m_boundaryBoxColor" ref="b76bfe86033c2692ecde47afc1e19997" args="" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b76bfe86033c2692ecde47afc1e19997">m_boundaryBoxColor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The color of the bounding box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d438180f73d505409651e7c1d8638c8"></a><!-- doxytag: member="cGenericObject::m_collisionDetector" ref="1d438180f73d505409651e7c1d8638c8" args="" -->
<a class="el" href="classc_generic_collision.html">cGenericCollision</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#1d438180f73d505409651e7c1d8638c8">m_collisionDetector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The collision detector used to test for contact with this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4307d3f5fce5146815e37778316376c3"></a><!-- doxytag: member="cGenericObject::m_frameGL" ref="4307d3f5fce5146815e37778316376c3" args="" -->
<a class="el" href="structc_matrix_g_l.html">cMatrixGL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#4307d3f5fce5146815e37778316376c3">m_frameGL</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OpenGL matrix describing my position and orientation transformation. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class is the root of basically every render-able object in CHAI. It defines a reference frame (position and rotation) and virtual methods for rendering, which are overloaded by useful subclasses. 
<p>
This class also defines basic methods for maintaining a scene graph, and propagating rendering passes and reference frame changes through a hierarchy of cGenericObjects.<p>
Besides subclassing, a useful way to extend <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a> is to store custom data in the m_tag and m_userData member fields, which are not used by CHAI.<p>
The most important methods to look at here are probably the virtual methods, which are listed last in <a class="el" href="_c_generic_object_8h.html">CGenericObject.h</a> . These methods will be called on each <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a> as operations propagate through the scene graph. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="422566b11cfee02a4db559c288fedd58"></a><!-- doxytag: member="cGenericObject::cGenericObject" ref="422566b11cfee02a4db559c288fedd58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cGenericObject::cGenericObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>. 
<p>
Constructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>. 
</div>
</div><p>
<a class="anchor" name="587289693b38360ecc66684ec94c9209"></a><!-- doxytag: member="cGenericObject::~cGenericObject" ref="587289693b38360ecc66684ec94c9209" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cGenericObject::~cGenericObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>. 
<p>
Destructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>. This function deletes all children starting from this point in the scene graph, so if you have objects that shouldn't be deleted, be sure to remove them from the scene graph before deleting their parents. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f5189d2e6a0456c2d5f257ca8bdf360a"></a><!-- doxytag: member="cGenericObject::renderSceneGraph" ref="f5189d2e6a0456c2d5f257ca8bdf360a" args="(const int a_renderMode=CHAI_RENDER_MODE_RENDER_ALL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::renderSceneGraph           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_renderMode</em> = <code>CHAI_RENDER_MODE_RENDER_ALL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render the entire scene graph, starting from this object. 
<p>
Render the scene graph starting at this object. This method is called for each object and optionally renders the object itself, its reference frame and the collision and/or scenegraph trees.<p>
The object itself is rendered by calling <a class="el" href="classc_generic_object.html#7eb87a0e7dd896f081854e693e4f60d9" title="Render this object in OpenGL.">render()</a>, which should be defined for each subclass that has a graphical representation. renderSceneGraph does not generally need to be over-ridden in subclasses.<p>
The a_renderMode parameter is used to allow multiple rendering passes, and takes one of the following values:<p>
CHAI_RENDER_MODE_NON_TRANSPARENT_ONLY=0, CHAI_RENDER_MODE_TRANSPARENT_BACK_ONLY, CHAI_RENDER_MODE_TRANSPARENT_FRONT_ONLY, CHAI_RENDER_MODE_RENDER_ALL<p>
If you have multipass transparency disabled (see <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a>), your objects will only be rendered once per frame, with a_renderMode set to CHAI_RENDER_MODE_RENDER_ALL. This is the default, and unless you enable multipass transparency, you don't ever need to care about a_renderMode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_renderMode</em>&nbsp;</td><td>Rendering mode </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classc_generic_shader.html#6b032cd01cb9b1dd3b30886afaf44017">cGenericShader</a>.
</div>
</div><p>
<a class="anchor" name="b08a1331c6217e833acf95466799962f"></a><!-- doxytag: member="cGenericObject::translate" ref="b08a1331c6217e833acf95466799962f" args="(const cVector3d &amp;a_translation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::translate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_translation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translate this object by a specified offset. 
<p>
Translate this object by a specified offset<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_translation</em>&nbsp;</td><td>Translation offset </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92df52ff262a682849a1e572393ff9b4"></a><!-- doxytag: member="cGenericObject::translate" ref="92df52ff262a682849a1e572393ff9b4" args="(const double a_x, const double a_y, const double a_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::translate           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translate this object by a specified offset. 
<p>
Translate an object by a specified offset<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_x</em>&nbsp;</td><td>Translation component X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_y</em>&nbsp;</td><td>Translation component Y </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_z</em>&nbsp;</td><td>Translation component Z </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bba165a0395766782e2dbe7735efe8a9"></a><!-- doxytag: member="cGenericObject::rotate" ref="bba165a0395766782e2dbe7735efe8a9" args="(const cMatrix3d &amp;a_rotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::rotate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_rotation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate this object by multiplying with a specified rotation matrix. 
<p>
Rotate this object by multiplying with a specified rotation matrix<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_rotation</em>&nbsp;</td><td>Rotation matrix </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9b82697b12cefa4a9601a45e055f8cb"></a><!-- doxytag: member="cGenericObject::rotate" ref="f9b82697b12cefa4a9601a45e055f8cb" args="(const cVector3d &amp;a_axis, const double a_angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::rotate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate this object around axis a_axis by angle a_angle (radians). 
<p>
Rotate this object around axis a_axis by angle a_angle (radians). a_axis is not normalized, so unless you know what you're doing, normalize your axis before supplying it to this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_axis</em>&nbsp;</td><td>Rotation axis </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_angle</em>&nbsp;</td><td>Rotation angle in radians </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab21f63a5cf247f607158ca1e7422617"></a><!-- doxytag: member="cGenericObject::computeGlobalPositions" ref="ab21f63a5cf247f607158ca1e7422617" args="(const bool a_frameOnly=true, const cVector3d &amp;a_globalPos=cVector3d(0.0, 0.0, 0.0), const cMatrix3d &amp;a_globalRot=cIdentity3d())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::computeGlobalPositions           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_frameOnly</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_globalPos</em> = <code><a class="el" href="structc_vector3d.html">cVector3d</a>(0.0,&nbsp;0.0,&nbsp;0.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_globalRot</em> = <code>cIdentity3d()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the global position and rotation of this object and its children. 
<p>
Compute globalPos and globalRot given the localPos and localRot of this object and its parents. Optionally propagates to children.<p>
If <em>a_frameOnly</em> is set to <b>false</b>, additional global positions such as vertex positions are computed (which can be time-consuming).<p>
Call this method any time you've moved an object and will need to access to globalPos and globalRot in this object or its children. For performance reasons, these values are not kept up-to-date by default, since almost all operations use local positions and rotations.?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_frameOnly</em>&nbsp;</td><td>If <b>true</b> then only the global frame is computed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_globalPos</em>&nbsp;</td><td>Global position of my parent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_globalRot</em>&nbsp;</td><td>Global rotation matrix of my parent </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af669adcf2a807bc30b5298b6985f24f"></a><!-- doxytag: member="cGenericObject::computeGlobalCurrentObjectOnly" ref="af669adcf2a807bc30b5298b6985f24f" args="(const bool a_frameOnly=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::computeGlobalCurrentObjectOnly           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_frameOnly</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the global position and rotation of current object only. 
<p>
Compute globalPos and globalRot for this object only, by recursively climbing up the scene graph tree until the root is reached.<p>
If <em>a_frameOnly</em> is set to <b>false</b>, additional global positions such as vertex positions are computed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_frameOnly</em>&nbsp;</td><td>If <b>true</b> then only the global frame is computed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c575d5fd60c350de14aff012874cdf20"></a><!-- doxytag: member="cGenericObject::computeCollisionDetection" ref="c575d5fd60c350de14aff012874cdf20" args="(cVector3d &amp;a_segmentPointA, const cVector3d &amp;a_segmentPointB, cGenericObject *&amp;a_colObject, cTriangle *&amp;a_colTriangle, cVector3d &amp;a_colPoint, double &amp;a_colSquareDistance, const bool a_visibleObjectsOnly=false, const int a_proxyCall=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::computeCollisionDetection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>a_colObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_triangle.html">cTriangle</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>a_colTriangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_colPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a_colSquareDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_visibleObjectsOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_proxyCall</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute collision detection using collision trees. 
<p>
Determine whether the given segment intersects a triangle in this object (or any of its descendants). The segment is described by a start point <em>a_segmentPointA</em> and end point <em>a_segmentPointB</em>. Collision detection functions of all children of this object are called, which recursively call the collision detection functions for all of this object's descendants. If there is more than one collision, the one closest to a_segmentPointA is the one returned.<p>
For any dynamic objects in the world with valid position and rotation histories (as indicated by the m_historyValid member of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>), the first endpoint of the segment is adjusted so that it is in the same location relative to the moved object as it was at the previous haptic iteration (provided the object's m_lastRot and m_lastPos were updated), so that collisions between the segment and the moving object can be properly detected. If the returned collision is with a moving object, the actual parameter corresponding to a_segmentPointA is set to the adjusted position for that object.<p>
If a collision(s) is located, information about the (closest) collision is stored in the corresponding parameters <em>a_colObject</em>, <em>a_colTriangle</em>, <em>a_colPoint</em>, and <em>a_colDistance</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointA</em>&nbsp;</td><td>Start point of segment. Value may be changed if returned collision is with a moving object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointB</em>&nbsp;</td><td>End point of segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_colObject</em>&nbsp;</td><td>Pointer to nearest collided object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_colTriangle</em>&nbsp;</td><td>Pointer to nearest collided triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_colPoint</em>&nbsp;</td><td>Position of nearest collision. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_colSquareDistance</em>&nbsp;</td><td>Squared distance between segment origin and nearest collision point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_visibleObjectsOnly</em>&nbsp;</td><td>Should we ignore invisible objects? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_proxyCall</em>&nbsp;</td><td>If this is &gt; 0, this is a call from a proxy, and the value of a_proxyCall specifies which call this is. -1 for non-proxy calls. </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classc_world.html#aabb7d849440d7dffa0ad78db2dfb8be">cWorld</a>.
</div>
</div><p>
<a class="anchor" name="c8d9678dab8af65567544d55118fd967"></a><!-- doxytag: member="cGenericObject::AdjustCollisionSegment" ref="c8d9678dab8af65567544d55118fd967" args="(cVector3d &amp;a_segmentPointA, cVector3d &amp;a_localSegmentPointA, const cGenericObject *a_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::AdjustCollisionSegment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_localSegmentPointA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjust collision segment for dynamic objects. 
<p>
Adjust the given segment such that it tests for intersection of the ray with objects at their previous positions at the last haptic loop so that collision detection will work in a dynamic environment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointA</em>&nbsp;</td><td>Start point of segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_localSegmentPointA</em>&nbsp;</td><td>Same segment, adjusted to be in local space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object that may have moved since last iteration. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5732cfc65122618a7857809d3cad9e06"></a><!-- doxytag: member="cGenericObject::computeForces" ref="5732cfc65122618a7857809d3cad9e06" args="(const cVector3d &amp;a_probePosition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc_vector3d.html">cVector3d</a> cGenericObject::computeForces           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_probePosition</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Descend through child objects to compute interaction forces for all cGenericPotentialFields. 
<p>
Descend through child objects to compute interaction forces for all <a class="el" href="classc_generic_potential_field.html" title="cGenericPotentialField describes a generic class to create objects which are describe...">cGenericPotentialField</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_probePosition</em>&nbsp;</td><td>Position of the probe in my parent's coordinate frame </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the computed force in my parent's coordinate frame </dd></dl>

<p>
Reimplemented in <a class="el" href="classc_generic_potential_field.html#99319e945d96880feb08c7de4537b8c3">cGenericPotentialField</a>.
</div>
</div><p>
<a class="anchor" name="532d70717dbac5a6b974d61dee5722a7"></a><!-- doxytag: member="cGenericObject::setShow" ref="532d70717dbac5a6b974d61dee5722a7" args="(const bool a_show, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShow           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_show</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide this object, optionally propagating the change to children. 
<p>
Show or hide this object.<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_show</em>&nbsp;</td><td>If <b>true</b> object shape is visible. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6c9067771330437a4906eb90e45db334"></a><!-- doxytag: member="cGenericObject::setHapticEnabled" ref="6c9067771330437a4906eb90e45db334" args="(const bool a_hapticEnabled, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setHapticEnabled           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_hapticEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow this object to be felt (when visible), optionally propagating the change to children. 
<p>
Allow or disallow the object to be felt (when visible).<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_hapticEnabled</em>&nbsp;</td><td>If <b>true</b> object can be felt when visible. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="363edb61b70cd06722a7b9d9594da1da"></a><!-- doxytag: member="cGenericObject::setShowTree" ref="363edb61b70cd06722a7b9d9594da1da" args="(const bool a_showTree, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShowTree           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide the child/parent tree, optionally propagating the change to children. 
<p>
Show or hide the graphic representation of the scene graph at this node.<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showTree</em>&nbsp;</td><td>If <b>true</b> then tree is displayed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec8f42b031fb0140633b5cb73e16094b"></a><!-- doxytag: member="cGenericObject::setTreeColor" ref="ec8f42b031fb0140633b5cb73e16094b" args="(const cColorf &amp;a_treeColor, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setTreeColor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_colorf.html">cColorf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_treeColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the tree color, optionally propagating the change to children. 
<p>
Set the color of the graphic representation of the scene graph at this node.<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_treeColor</em>&nbsp;</td><td>Color of tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="645192ff03d772d141a2e391fe355910"></a><!-- doxytag: member="cGenericObject::setShowFrame" ref="645192ff03d772d141a2e391fe355910" args="(const bool a_showFrame, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShowFrame           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide the reference frame arrows for this object, optionally propagating the change to children. 
<p>
Show or hide the set of arrows that represent this object's reference frame.<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showFrame</em>&nbsp;</td><td>If <b>true</b> then frame is displayed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3d1b3334e5dcb92ff585694f1b18d7f7"></a><!-- doxytag: member="cGenericObject::setShowBox" ref="3d1b3334e5dcb92ff585694f1b18d7f7" args="(const bool iShowBox, const bool iAffectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShowBox           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide the boundary box for this object, optionally propagating the change to children. 
<p>
Show or hide the graphic representation of the boundary box of this object.<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showBox</em>&nbsp;</td><td>If <b>true</b>, boundary box is displayed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="36189f1d90cb10cbddb429d5789eef9f"></a><!-- doxytag: member="cGenericObject::setBoxColor" ref="36189f1d90cb10cbddb429d5789eef9f" args="(const cColorf &amp;a_boxColor, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setBoxColor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_colorf.html">cColorf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_boxColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the color of boundary box for this object, optionally propagating the change to children. 
<p>
Set the color of the graphic representation of the boundary boundary box of this object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_boxColor</em>&nbsp;</td><td>Color of boundary box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="860091e53c3913532cd1c00d55042b87"></a><!-- doxytag: member="cGenericObject::showCollisionTree" ref="860091e53c3913532cd1c00d55042b87" args="(const bool a_showCollisionTree, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::showCollisionTree           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showCollisionTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide the collision tree for this object, optionally propagating the change to children. 
<p>
Show or hide the graphic representation of the collision tree at this node.<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showCollisionTree</em>&nbsp;</td><td>If <b>true</b>, small normals are rendered graphicaly. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bceaa39ca365c7092d4b3932665439d8"></a><!-- doxytag: member="cGenericObject::onDisplayReset" ref="bceaa39ca365c7092d4b3932665439d8" args="(const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::onDisplayReset           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function should get called when it's necessary to re-initialize the OpenGL context. 
<p>
Users should call this function when it's necessary to re-initialize the OpenGL context; e.g. re-initialize textures and display lists. Subclasses should perform whatever re-initialization they need to do.<p>
Note that this is not an event CHAI can easily detect, so it's up to the application-writer to call this function on the root of the scenegraph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classc_generic_shader.html#e53531997718985b42f1344e100ec632">cGenericShader</a>, <a class="el" href="classc_camera.html#855eb0c3bfea98decf9b2bda0bf4c1ca">cCamera</a>, <a class="el" href="classc_mesh.html#7fc10e529990bc678f026a9f7d1607e2">cMesh</a>, <a class="el" href="classc_v_b_o_mesh.html#10610f7342143e1972f61cc815652fbc">cVBOMesh</a>, <a class="el" href="classc_world.html#c9bbc08506ccede9d5213449c33273a3">cWorld</a>, and <a class="el" href="classc_label_panel.html#c1a769e38a2306977d702e7b25c2a608">cLabelPanel</a>.
</div>
</div><p>
<a class="anchor" name="ca3d6fc97084c2ab439d2486d98e23e6"></a><!-- doxytag: member="cGenericObject::finalize" ref="ca3d6fc97084c2ab439d2486d98e23e6" args="(const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::finalize           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function tells children that you're not going to change their contents any more. 
<p>
This call tells an object that you're not going to modify him any more. For example, a mesh-like object might optimize his vertex arrangement when he gets this call. Always optional; just for performance...<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classc_v_b_o_mesh.html#256e5a89f5dab69469b5d548e4e1f255">cVBOMesh</a>.
</div>
</div><p>
<a class="anchor" name="c6bf258cebfd460192b3a1383266ea95"></a><!-- doxytag: member="cGenericObject::unfinalize" ref="c6bf258cebfd460192b3a1383266ea95" args="(const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::unfinalize           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function tells objects that you may modify their contents. 
<p>
This call tells an object that you may modify his contents. See <a class="el" href="classc_generic_object.html#ca3d6fc97084c2ab439d2486d98e23e6" title="This function tells children that you're not going to change their contents any more...">finalize()</a> for more information.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classc_v_b_o_mesh.html#0e29e8d9af1a54d70ec787311ad4ef87">cVBOMesh</a>.
</div>
</div><p>
<a class="anchor" name="c43081628c7ae8577dcb270983eea2e6"></a><!-- doxytag: member="cGenericObject::setFrameSize" ref="c43081628c7ae8577dcb270983eea2e6" args="(const double a_size=1.0, const double a_thickness=1.0, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::setFrameSize           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_size</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_thickness</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the size of the rendered reference frame, optionally propagating the change to children. 
<p>
Set the display size of the arrows representing my reference frame. The size corresponds to the length of each displayed axis (X-Y-Z).<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_size</em>&nbsp;</td><td>Length of graphical representation of frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_thickness</em>&nbsp;</td><td>Thickness of graphical representation of frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="152b67a212d8f359ec7a24d2c8be7a33"></a><!-- doxytag: member="cGenericObject::computeBoundaryBox" ref="152b67a212d8f359ec7a24d2c8be7a33" args="(const bool a_includeChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::computeBoundaryBox           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Re-compute this object's bounding box, optionally forcing it to bound child objects. 
<p>
Compute the bounding box of this object and (optionally) its children.<p>
If parameter <em>a_includeChildren</em> is set to <b>true</b> then each object's bounding box covers its own volume and the volume of its children.<p>
Note that regardless of this parameter's value, this operation propagates down the scene graph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If true, then children are included. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="22abb35355c5be8622be3cac2e6fb510"></a><!-- doxytag: member="cGenericObject::setCollisionDetectorProperties" ref="22abb35355c5be8622be3cac2e6fb510" args="(unsigned int a_displayDepth, cColorf &amp;a_color, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setCollisionDetectorProperties           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_displayDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_colorf.html">cColorf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set collision rendering properties. 
<p>
Set the rendering properties for the graphic representation of collision detection tree at this node.<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_color</em>&nbsp;</td><td>Color used to render collision detector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_displayDepth</em>&nbsp;</td><td>Indicated which depth of collision tree needs to be displayed (see <a class="el" href="classc_generic_collision.html" title="cGenericCollision is an abstract class for collision-detection algorithms for meshes...">cGenericCollision</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If true, all children are updated </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e923e09ba8708ecc49f423f0ef68fba8"></a><!-- doxytag: member="cGenericObject::deleteCollisionDetector" ref="e923e09ba8708ecc49f423f0ef68fba8" args="(const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::deleteCollisionDetector           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete any existing collision detector and set the current cd to null (no collisions). 
<p>
Delete any existing collision detector and set the current cd to null. It's fine for an object to have a null collision detector (that's the default for a new object, in fact), it just means that no collisions will be found.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If true, all my children's cd's are also deleted </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="84e3f5d5cd786a987c77ed19eed4c054"></a><!-- doxytag: member="cGenericObject::addChild" ref="84e3f5d5cd786a987c77ed19eed4c054" args="(cGenericObject *a_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::addChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an object to my list of children. 
<p>
Adds an object to the scene graph below this object<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object to be added to children list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="90e5033f96dc1e891cac79e5e56e1424"></a><!-- doxytag: member="cGenericObject::removeChild" ref="90e5033f96dc1e891cac79e5e56e1424" args="(cGenericObject *a_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::removeChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an object from my list of children, without deleting it. 
<p>
Removes an object from my list of children, without deleting the child object from memory.<p>
This method assigns the child object's parent point to null, so if you're moving someone around in your scene graph, make sure you call this function _before_ you add the child to another node in the scene graph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object to be removed from my list of children </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns true if the specified object was found on my list of children </dd></dl>

</div>
</div><p>
<a class="anchor" name="d54d4284c0ca71d2e199080bc3559878"></a><!-- doxytag: member="cGenericObject::containsChild" ref="d54d4284c0ca71d2e199080bc3559878" args="(cGenericObject *a_object, bool a_includeChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::containsChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this object have the specified object as a child? 
<p>
Does this object have the specified object as a child?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>Should we also search this object's descendants? </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b612f2a2121062bd70b1096bc51a6895"></a><!-- doxytag: member="cGenericObject::deleteChild" ref="b612f2a2121062bd70b1096bc51a6895" args="(cGenericObject *a_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::deleteChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an object from my list of children and delete it. 
<p>
Removes an object from my list of children, and deletes the child object from memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object to be removed from my list of children and deleted </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns true if the specified object was found on my list of children </dd></dl>

</div>
</div><p>
<a class="anchor" name="f56e64f9db66bc82e51c44e756e13495"></a><!-- doxytag: member="cGenericObject::clearAllChildren" ref="f56e64f9db66bc82e51c44e756e13495" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::clearAllChildren           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear all objects from my list of children, without deleting them. 
<p>
Clear all objects from my list of children, without deleting them 
</div>
</div><p>
<a class="anchor" name="a1552a230244d2119043026e03aef8f2"></a><!-- doxytag: member="cGenericObject::deleteAllChildren" ref="a1552a230244d2119043026e03aef8f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::deleteAllChildren           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear and delete all objects from my list of children. 
<p>
Delete and clear all objects from my list of children 
</div>
</div><p>
<a class="anchor" name="746f4083ff824c30a246cd01c17893a1"></a><!-- doxytag: member="cGenericObject::getNumDescendants" ref="746f4083ff824c30a246cd01c17893a1" args="(bool a_includeCurrentObject=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cGenericObject::getNumDescendants           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeCurrentObject</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return my total number of descendants, optionally including this object. 
<p>
Return my total number of descendants, optionally including this object<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_includeCurrentObject</em>&nbsp;</td><td>Should I include myself in the count? </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="58001a089d78289dde9adfc2403a6a62"></a><!-- doxytag: member="cGenericObject::enumerateChildren" ref="58001a089d78289dde9adfc2403a6a62" args="(std::list&lt; cGenericObject * &gt; &amp;a_childList, bool a_includeCurrentObject=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::enumerateChildren           </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="classc_generic_object.html">cGenericObject</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a_childList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeCurrentObject</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill this list with all of my descendants. 
<p>
Fill this list with all of my descendants. The current object is optionally included in this list. Does not clear the list before appending to it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_childList</em>&nbsp;</td><td>The list to write our enumerated results to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeCurrentObject</em>&nbsp;</td><td>Should I include myself on the list? </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9be8abb917b1f84e5196c0213aca1617"></a><!-- doxytag: member="cGenericObject::scale" ref="9be8abb917b1f84e5196c0213aca1617" args="(const double &amp;a_scaleFactor, const bool a_includeChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::scale           </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&nbsp;</td>
          <td class="paramname"> <em>a_scaleFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scale this object by a_scaleFactor (uniform scale). 
<p>
Uniform scale, optionally include children. Not necessarily implemented in all subclasses. Does nothing at the <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a> level; subclasses should scale themselves, then call the superclass method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_scaleFactor</em>&nbsp;</td><td>Scale factor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If true, this message is passed to children. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8bdcfa16951b6da2f8c6f0b95d2d9500"></a><!-- doxytag: member="cGenericObject::scale" ref="8bdcfa16951b6da2f8c6f0b95d2d9500" args="(const cVector3d &amp;a_scaleFactors, const bool a_includeChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::scale           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_scaleFactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-uniform scale. 
<p>
Non-uniform scale, optionally include children. Not necessarily implemented in all subclasses. Does nothing at the <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a> level; subclasses should scale themselves, then call the superclass method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_scaleFactors</em>&nbsp;</td><td>Possibly non-uniform scale factors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If true, this message is passed to children. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="001853c55875d15fc535f6806ac0b47b"></a><!-- doxytag: member="cGenericObject::setTag" ref="001853c55875d15fc535f6806ac0b47b" args="(const int a_tag, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setTag           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the tag for this object and - optionally - for my children. 
<p>
Set the tag for this object and - optionally - for my children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_tag</em>&nbsp;</td><td>The tag we'll assign to this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af6da87dec3f13c00fd338ea9af1c9fc"></a><!-- doxytag: member="cGenericObject::setUserData" ref="af6da87dec3f13c00fd338ea9af1c9fc" args="(void *a_data, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setUserData           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the m_userData pointer for this object and - optionally - for my children. 
<p>
Set the m_userData pointer for this object and - optionally - for my children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_data</em>&nbsp;</td><td>The pointer to which we will set m_userData </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8a1cce0f5d34a968da81bcb54524e8b1"></a><!-- doxytag: member="cGenericObject::setName" ref="8a1cce0f5d34a968da81bcb54524e8b1" args="(const char *a_name, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>a_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the name for this object and - optionally - for my children. 
<p>
Set the name for this object and - optionally - for my children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_name</em>&nbsp;</td><td>The name we'll assign to this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7eb87a0e7dd896f081854e693e4f60d9"></a><!-- doxytag: member="cGenericObject::render" ref="7eb87a0e7dd896f081854e693e4f60d9" args="(const int a_renderMode=CHAI_RENDER_MODE_RENDER_ALL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::render           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_renderMode</em> = <code>CHAI_RENDER_MODE_RENDER_ALL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render this object in OpenGL. 
<p>
Render this object. Subclasses will generally override this method. This is called from renderSceneGraph, which subclasses generally do not need to override.<p>
The a_renderMode parameter is used to allow multiple rendering passes, and takes one of the following values:<p>
CHAI_RENDER_MODE_NON_TRANSPARENT_ONLY=0, CHAI_RENDER_MODE_TRANSPARENT_BACK_ONLY, CHAI_RENDER_MODE_TRANSPARENT_FRONT_ONLY, CHAI_RENDER_MODE_RENDER_ALL<p>
If you have multipass transparency disabled (see <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a>), your objects will only be rendered once per frame, with a_renderMode set to CHAI_RENDER_MODE_RENDER_ALL. This is the default, and unless you enable multipass transparency, you don't ever need to care about a_renderMode.<p>
A word on OpenGL conventions:<p>
CHAI does not re-initialize the OpenGL state at every rendering pass. The only OpenGL state variables that CHAI sets explicitly in a typical rendering pass are:<p>
lighting is enabled (<a class="el" href="classc_world.html" title="cWorld defines the typical root of the CHAI scene graph. It stores lights, allocates...">cWorld</a>) depth-testing is enabled (<a class="el" href="classc_world.html" title="cWorld defines the typical root of the CHAI scene graph. It stores lights, allocates...">cWorld</a>) glColorMaterial is enabled and set to GL_AMBIENT_AND_DIFFUSE/GL_FRONT_AND_BACK (<a class="el" href="classc_world.html" title="cWorld defines the typical root of the CHAI scene graph. It stores lights, allocates...">cWorld</a>) a perspective projection matrix is set up (<a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a>)<p>
This adherence to the defaults is nice because it lets an application change an important piece of state globally and not worry about it getting changed by CHAI objects.<p>
It is expected that objects will "clean up after themselves" if they change any rendering state besides:<p>
color (glColor) material properties (glMaterial) normals (glNormal)<p>
For example, if my object changes the rendering color, I don't need to set it back before returning, but if my object turns on vertex buffering, I should turn it off before returning. Consequently if I care about the current color, I should set it up in my own <a class="el" href="classc_generic_object.html#7eb87a0e7dd896f081854e693e4f60d9" title="Render this object in OpenGL.">render()</a> function, because I shouldn't count on it being meaningful when my <a class="el" href="classc_generic_object.html#7eb87a0e7dd896f081854e693e4f60d9" title="Render this object in OpenGL.">render()</a> function is called.<p>
Necessary exceptions to these conventions include:<p>
<a class="el" href="classc_light.html" title="cLight describes an OpenGL light source, generally rendered by a cWorld object, which...">cLight</a> will change the lighting state for his assigned GL_LIGHT <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a> sets up relevant transformation matrices<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_renderMode</em>&nbsp;</td><td>Rendering mode; see above </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classc_mesh.html#dd34043a0d263f2353c79985c9ca4098">cMesh</a>, <a class="el" href="classc_shape_sphere.html#ea8623107c526cb97a2ca3c4dd3d9aa4">cShapeSphere</a>, <a class="el" href="classc_shape_torus.html#8a56ab6e6f76a42e2fc7898c424e8e4d">cShapeTorus</a>, <a class="el" href="classc_world.html#dcc79277c1b0681354a5592c4c14a4af">cWorld</a>, <a class="el" href="classc_generic3dof_pointer.html#a9cf38d952ea72a75b036d1178c100ad">cGeneric3dofPointer</a>, <a class="el" href="classc_generic_tool.html#186f10f08692ee8638473242ecbd00a7">cGenericTool</a>, <a class="el" href="classc_bitmap.html#4c0ee48217d983eb52af86a9e2555852">cBitmap</a>, <a class="el" href="classc_label_panel.html#d0d4fdbe0b51862dfabfe8120668431f">cLabelPanel</a>, and <a class="el" href="classc_panel.html#4816679ebae577b041e4eab2ef29a27b">cPanel</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>chai3d/src/scenegraph/<a class="el" href="_c_generic_object_8h.html">CGenericObject.h</a><li>chai3d/src/scenegraph/CGenericObject.cpp</ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jun 11 09:41:47 2007 for CHAI 3D by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
