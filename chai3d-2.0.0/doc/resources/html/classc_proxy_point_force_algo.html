<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CHAI3D: cProxyPointForceAlgo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cProxyPointForceAlgo Class Reference<br>
<small>
[<a class="el" href="group__forces.html">Force Rendering Algorithms</a>]</small>
</h1><!-- doxytag: class="cProxyPointForceAlgo" --><!-- doxytag: inherits="cGenericPointForceAlgo" -->Implements the finger-proxy algorithm for computing interaction forces between a point force device and meshes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_c_proxy_point_force_algo_8h_source.html">CProxyPointForceAlgo.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for cProxyPointForceAlgo:</div>
<div class="dynsection">
<p><center><img src="classc_proxy_point_force_algo__inherit__graph.png" border="0" usemap="#c_proxy_point_force_algo__inherit__map" alt="Inheritance graph"></center>
<map name="c_proxy_point_force_algo__inherit__map">
<area shape="rect" id="node2" href="classc_generic_point_force_algo.html" title="cGenericPointForceAlgo is an abstract class for algorithms that compute single point..." alt="" coords="5,6,168,34"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classc_proxy_point_force_algo-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2d00616ad7692c57a06133bfc56631e"></a><!-- doxytag: member="cProxyPointForceAlgo::cProxyPointForceAlgo" ref="e2d00616ad7692c57a06133bfc56631e" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#e2d00616ad7692c57a06133bfc56631e">cProxyPointForceAlgo</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of <a class="el" href="classc_proxy_point_force_algo.html" title="Implements the finger-proxy algorithm for computing interaction forces between a...">cProxyPointForceAlgo</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="56a297c4edb6e56ec0449850b447f3bd"></a><!-- doxytag: member="cProxyPointForceAlgo::~cProxyPointForceAlgo" ref="56a297c4edb6e56ec0449850b447f3bd" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#56a297c4edb6e56ec0449850b447f3bd">~cProxyPointForceAlgo</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor of <a class="el" href="classc_proxy_point_force_algo.html" title="Implements the finger-proxy algorithm for computing interaction forces between a...">cProxyPointForceAlgo</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#324b2f8ed022284be4d364eb92c6f311">initialize</a> (<a class="el" href="classc_world.html">cWorld</a> *a_world, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_initialGlobalPosition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the algorithm.  <a href="#324b2f8ed022284be4d364eb92c6f311"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#332391597c8661ade770839f00e05412">reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the algorithm. Set proxy position to device position.  <a href="#332391597c8661ade770839f00e05412"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#7a171dac090c8a2a81eeebf465590414">computeForces</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolPos, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolVel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate interaction forces between device and meshes.  <a href="#7a171dac090c8a2a81eeebf465590414"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fc7ab8a23ee84bc3ef37cc0ce79a723"></a><!-- doxytag: member="cProxyPointForceAlgo::setProxyRadius" ref="5fc7ab8a23ee84bc3ef37cc0ce79a723" args="(const double &amp;a_radius)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#5fc7ab8a23ee84bc3ef37cc0ce79a723">setProxyRadius</a> (const double &amp;a_radius)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set radius of proxy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb390296516ace34c0e36e0d5d8ae24c"></a><!-- doxytag: member="cProxyPointForceAlgo::getProxyRadius" ref="fb390296516ace34c0e36e0d5d8ae24c" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#fb390296516ace34c0e36e0d5d8ae24c">getProxyRadius</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read radius of proxy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a60d877a3967e368bd3e3b1d7816e37e"></a><!-- doxytag: member="cProxyPointForceAlgo::getProxyGlobalPosition" ref="a60d877a3967e368bd3e3b1d7816e37e" args="() const " -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#a60d877a3967e368bd3e3b1d7816e37e">getProxyGlobalPosition</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last computed position of proxy in world coordinates. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2445b16d27c7f8f4fe9bc91720533c69"></a><!-- doxytag: member="cProxyPointForceAlgo::setProxyGlobalPosition" ref="2445b16d27c7f8f4fe9bc91720533c69" args="(const cVector3d &amp;a_position)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#2445b16d27c7f8f4fe9bc91720533c69">setProxyGlobalPosition</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set position of proxy in world coordinates. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5ce6047e4a20a516f41a81a4d59b19f7"></a><!-- doxytag: member="cProxyPointForceAlgo::getDeviceGlobalPosition" ref="5ce6047e4a20a516f41a81a4d59b19f7" args="() const " -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#5ce6047e4a20a516f41a81a4d59b19f7">getDeviceGlobalPosition</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last specified position of device in world coordinates. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="109874360f28672476bad89ee0b390a3"></a><!-- doxytag: member="cProxyPointForceAlgo::getForce" ref="109874360f28672476bad89ee0b390a3" args="()" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#109874360f28672476bad89ee0b390a3">getForce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last computed force vector in world coordinates. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0d30616cda6054c7e78cbc62144bf31"></a><!-- doxytag: member="cProxyPointForceAlgo::getNormalForce" ref="b0d30616cda6054c7e78cbc62144bf31" args="()" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#b0d30616cda6054c7e78cbc62144bf31">getNormalForce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return most recently calculated normal force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02066353fe4a3612ab010e9c0cbedb8e"></a><!-- doxytag: member="cProxyPointForceAlgo::getTangentialForce" ref="02066353fe4a3612ab010e9c0cbedb8e" args="()" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#02066353fe4a3612ab010e9c0cbedb8e">getTangentialForce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return most recently calculated tangential force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e04f012615c901ef85ff8e2f26570c72"></a><!-- doxytag: member="cProxyPointForceAlgo::getNumContacts" ref="e04f012615c901ef85ff8e2f26570c72" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#e04f012615c901ef85ff8e2f26570c72">getNumContacts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of contacts (0, 1, 2 or 3):. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#9e27459dcd2332cd1193e86dda26dbb0">setEpsilonBaseValue</a> (double a_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set epsilon base value.  <a href="#9e27459dcd2332cd1193e86dda26dbb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4f45ecbb881a6785aa9cec97241e9040"></a><!-- doxytag: member="cProxyPointForceAlgo::getEpsilonBaseValue" ref="4f45ecbb881a6785aa9cec97241e9040" args="()" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#4f45ecbb881a6785aa9cec97241e9040">getEpsilonBaseValue</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read current epsilon value. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2033eea7fa37e4060bcccfac52c95f3d"></a><!-- doxytag: member="cProxyPointForceAlgo::m_contactPoint0" ref="2033eea7fa37e4060bcccfac52c95f3d" args="" -->
<a class="el" href="structc_collision_event.html">cCollisionEvent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#2033eea7fa37e4060bcccfac52c95f3d">m_contactPoint0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about collision point 0. Call <a class="el" href="classc_proxy_point_force_algo.html#e04f012615c901ef85ff8e2f26570c72" title="Return the number of contacts (0, 1, 2 or 3):.">getNumContacts()</a> to see if valid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="24680f0cfc4df1265b80c5296c75d3ec"></a><!-- doxytag: member="cProxyPointForceAlgo::m_contactPoint1" ref="24680f0cfc4df1265b80c5296c75d3ec" args="" -->
<a class="el" href="structc_collision_event.html">cCollisionEvent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#24680f0cfc4df1265b80c5296c75d3ec">m_contactPoint1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about collision point 1. Call <a class="el" href="classc_proxy_point_force_algo.html#e04f012615c901ef85ff8e2f26570c72" title="Return the number of contacts (0, 1, 2 or 3):.">getNumContacts()</a> to see if valid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34530340fdd845b44efb81ee8b2895bd"></a><!-- doxytag: member="cProxyPointForceAlgo::m_contactPoint2" ref="34530340fdd845b44efb81ee8b2895bd" args="" -->
<a class="el" href="structc_collision_event.html">cCollisionEvent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#34530340fdd845b44efb81ee8b2895bd">m_contactPoint2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about collision point 2. Call <a class="el" href="classc_proxy_point_force_algo.html#e04f012615c901ef85ff8e2f26570c72" title="Return the number of contacts (0, 1, 2 or 3):.">getNumContacts()</a> to see if valid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f593d4b8822f4f4fc44c697aacd2307"></a><!-- doxytag: member="cProxyPointForceAlgo::m_useFriction" ref="3f593d4b8822f4f4fc44c697aacd2307" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#3f593d4b8822f4f4fc44c697aacd2307">m_useFriction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use any friction algorithm? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d13846cfd08788786ea269c2e19c6a8d"></a><!-- doxytag: member="cProxyPointForceAlgo::m_useDynamicProxy" ref="d13846cfd08788786ea269c2e19c6a8d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d13846cfd08788786ea269c2e19c6a8d">m_useDynamicProxy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the dynamic proxy algorithm to deal with mobile objects? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="92c07b009f41dea194c6300493e4dab9"></a><!-- doxytag: member="cProxyPointForceAlgo::m_useForceShading" ref="92c07b009f41dea194c6300493e4dab9" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#92c07b009f41dea194c6300493e4dab9">m_useForceShading</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use force shading. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d793af77ccf02c99ea32ed2a55358b9f">m_frictionDynHysteresisMultiplier</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8dcdbfdb8afe04a883aa7926b8aa137c"></a><!-- doxytag: member="cProxyPointForceAlgo::m_forceShadingAngleThreshold" ref="8dcdbfdb8afe04a883aa7926b8aa137c" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#8dcdbfdb8afe04a883aa7926b8aa137c">m_forceShadingAngleThreshold</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum force shading angle (radians) threshold between normals of triangle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9f1ee81b911db086d62bea0bf66ad6ae"></a><!-- doxytag: member="cProxyPointForceAlgo::m_collisionSettings" ref="9f1ee81b911db086d62bea0bf66ad6ae" args="" -->
<a class="el" href="structc_collision_settings.html">cCollisionSettings</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#9f1ee81b911db086d62bea0bf66ad6ae">m_collisionSettings</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collision cettings. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#b8d938b2bef9cedceb5ad8aa66be80af">goalAchieved</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_proxy, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_goal) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the proxy has reached the goal point.  <a href="#b8d938b2bef9cedceb5ad8aa66be80af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#78ddcf5605d527bb8827adfa4b7e30d6">computeNextBestProxyPosition</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_goal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the next goal position of the proxy.  <a href="#78ddcf5605d527bb8827adfa4b7e30d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d21e4eb103a50b318495eefeb194d3fc">testFrictionAndMoveProxy</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_goal, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_proxy, <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_normal, <a class="el" href="classc_generic_object.html">cGenericObject</a> *a_parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to move the proxy, subject to friction constraints.  <a href="#d21e4eb103a50b318495eefeb194d3fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#05e761a70bd2a258f854e91d00cd3772">updateForce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute force to apply to device.  <a href="#05e761a70bd2a258f854e91d00cd3772"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87b7ab6dc23e3ff1c644bacc4633f1b3"></a><!-- doxytag: member="cProxyPointForceAlgo::computeNextProxyPositionWithContraints0" ref="87b7ab6dc23e3ff1c644bacc4633f1b3" args="(const cVector3d &amp;a_goalGlobalPos)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#87b7ab6dc23e3ff1c644bacc4633f1b3">computeNextProxyPositionWithContraints0</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_goalGlobalPos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the proxy algorithm - constraint 0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a2d58f74c8ac36ff8184518afd71c3a"></a><!-- doxytag: member="cProxyPointForceAlgo::computeNextProxyPositionWithContraints1" ref="2a2d58f74c8ac36ff8184518afd71c3a" args="(const cVector3d &amp;a_goalGlobalPos)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#2a2d58f74c8ac36ff8184518afd71c3a">computeNextProxyPositionWithContraints1</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_goalGlobalPos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the proxy algorithm - constraint 1. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e18482cd7985b7112402c61c0a36051"></a><!-- doxytag: member="cProxyPointForceAlgo::computeNextProxyPositionWithContraints2" ref="1e18482cd7985b7112402c61c0a36051" args="(const cVector3d &amp;a_goalGlobalPos)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#1e18482cd7985b7112402c61c0a36051">computeNextProxyPositionWithContraints2</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_goalGlobalPos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the proxy algorithm - constraint 2. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8b1b89c663de414731b176c9691a582"></a><!-- doxytag: member="cProxyPointForceAlgo::m_proxyGlobalPos" ref="e8b1b89c663de414731b176c9691a582" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#e8b1b89c663de414731b176c9691a582">m_proxyGlobalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global position of the proxy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="638d0c345486424ba818c79baaebefa2"></a><!-- doxytag: member="cProxyPointForceAlgo::m_deviceGlobalPos" ref="638d0c345486424ba818c79baaebefa2" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#638d0c345486424ba818c79baaebefa2">m_deviceGlobalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global position of device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d0b43f42fe9ddbe8ed088077aa19d459"></a><!-- doxytag: member="cProxyPointForceAlgo::m_lastGlobalForce" ref="d0b43f42fe9ddbe8ed088077aa19d459" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d0b43f42fe9ddbe8ed088077aa19d459">m_lastGlobalForce</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Last computed force (in global coordinate frame). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d4a704094a26e4eeba5ac95660f1e28"></a><!-- doxytag: member="cProxyPointForceAlgo::m_nextBestProxyGlobalPos" ref="1d4a704094a26e4eeba5ac95660f1e28" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#1d4a704094a26e4eeba5ac95660f1e28">m_nextBestProxyGlobalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next best position for the proxy (in global coordinate frame). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4305ff140536b66109c974173624e198"></a><!-- doxytag: member="cProxyPointForceAlgo::m_slipping" ref="4305ff140536b66109c974173624e198" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#4305ff140536b66109c974173624e198">m_slipping</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are we currently in a "slip friction" state? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98922c81c2c631b0068159072f0fc807"></a><!-- doxytag: member="cProxyPointForceAlgo::m_normalForce" ref="98922c81c2c631b0068159072f0fc807" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#98922c81c2c631b0068159072f0fc807">m_normalForce</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normal force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9ecb324aa05848daa965100803526af"></a><!-- doxytag: member="cProxyPointForceAlgo::m_tangentialForce" ref="b9ecb324aa05848daa965100803526af" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#b9ecb324aa05848daa965100803526af">m_tangentialForce</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tangential force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05d94278dccf47a77afad0f80e152f7c"></a><!-- doxytag: member="cProxyPointForceAlgo::m_numContacts" ref="05d94278dccf47a77afad0f80e152f7c" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#05d94278dccf47a77afad0f80e152f7c">m_numContacts</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of contacts between proxy and triangles (0, 1, 2 or 3). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dc9747ecec32cc212bb89283642f126b"></a><!-- doxytag: member="cProxyPointForceAlgo::m_radius" ref="dc9747ecec32cc212bb89283642f126b" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#dc9747ecec32cc212bb89283642f126b">m_radius</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Radius of the proxy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6412501e5b1f25f5f2f86cb05e70a871"></a><!-- doxytag: member="cProxyPointForceAlgo::m_collisionRecorderConstraint0" ref="6412501e5b1f25f5f2f86cb05e70a871" args="" -->
<a class="el" href="classc_collision_recorder.html">cCollisionRecorder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#6412501e5b1f25f5f2f86cb05e70a871">m_collisionRecorderConstraint0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collision detection recorder for searching first constraint. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dca49ca469618d0e7a96e026083d3b56"></a><!-- doxytag: member="cProxyPointForceAlgo::m_collisionRecorderConstraint1" ref="dca49ca469618d0e7a96e026083d3b56" args="" -->
<a class="el" href="classc_collision_recorder.html">cCollisionRecorder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#dca49ca469618d0e7a96e026083d3b56">m_collisionRecorderConstraint1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collision detection recorder for searching second constraint. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="621ab8344287188f8496cb88b01efc37"></a><!-- doxytag: member="cProxyPointForceAlgo::m_collisionRecorderConstraint2" ref="621ab8344287188f8496cb88b01efc37" args="" -->
<a class="el" href="classc_collision_recorder.html">cCollisionRecorder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#621ab8344287188f8496cb88b01efc37">m_collisionRecorderConstraint2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collision detection recorder for searching third constraint. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d8deb50730fcf140e87db3cd6704310e">m_epsilonInitialValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">epsilon value - used for handling numerical limits.  <a href="#d8deb50730fcf140e87db3cd6704310e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a81fcf35ccd632e7f478b4ea775a955d"></a><!-- doxytag: member="cProxyPointForceAlgo::m_epsilon" ref="a81fcf35ccd632e7f478b4ea775a955d" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#a81fcf35ccd632e7f478b4ea775a955d">m_epsilon</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">epsilon value - used for handling numerical limits. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a68b7123b382cea1de4cf0dbebc627d"></a><!-- doxytag: member="cProxyPointForceAlgo::m_epsilonCollisionDetection" ref="4a68b7123b382cea1de4cf0dbebc627d" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#4a68b7123b382cea1de4cf0dbebc627d">m_epsilonCollisionDetection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">epsilon value - used for handling numerical limits. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="edb957cd9ae8e34d98f63fa2311919c2"></a><!-- doxytag: member="cProxyPointForceAlgo::m_epsilonBaseValue" ref="edb957cd9ae8e34d98f63fa2311919c2" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#edb957cd9ae8e34d98f63fa2311919c2">m_epsilonBaseValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">epsilon value - used for handling numerical limits. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78178ada6704ea8689f0ef1d2491151a"></a><!-- doxytag: member="cProxyPointForceAlgo::m_epsilonMinimalValue" ref="78178ada6704ea8689f0ef1d2491151a" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#78178ada6704ea8689f0ef1d2491151a">m_epsilonMinimalValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">epsilon value - used for handling numerical limits. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="509293422c4fc792286f241551f799da"></a><!-- doxytag: member="cProxyPointForceAlgo::m_algoCounter" ref="509293422c4fc792286f241551f799da" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#509293422c4fc792286f241551f799da">m_algoCounter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value of state machine. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implements the finger-proxy algorithm for computing interaction forces between a point force device and meshes. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7a171dac090c8a2a81eeebf465590414"></a><!-- doxytag: member="cProxyPointForceAlgo::computeForces" ref="7a171dac090c8a2a81eeebf465590414" args="(const cVector3d &amp;a_toolPos, const cVector3d &amp;a_toolVel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc_vector3d.html">cVector3d</a> cProxyPointForceAlgo::computeForces           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_toolPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_toolVel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate interaction forces between device and meshes. 
<p>
This method computes the force to add to the device due to any collisions with meshes by calling <a class="el" href="classc_proxy_point_force_algo.html#78ddcf5605d527bb8827adfa4b7e30d6" title="Compute the next goal position of the proxy.">computeNextBestProxyPosition()</a> to update the proxy location and then computeForce() to calculate a force vector based on the proxy location.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_toolPos</em>&nbsp;</td><td>New position of tool </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_toolVel</em>&nbsp;</td><td>New velocity of tool </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return the force to add to the device due to any collisions with meshes. </dd></dl>

<p>Reimplemented from <a class="el" href="classc_generic_point_force_algo.html#54342d43a831f01c7b42fa00f4041196">cGenericPointForceAlgo</a>.</p>

</div>
</div><p>
<a class="anchor" name="78ddcf5605d527bb8827adfa4b7e30d6"></a><!-- doxytag: member="cProxyPointForceAlgo::computeNextBestProxyPosition" ref="78ddcf5605d527bb8827adfa4b7e30d6" args="(const cVector3d &amp;a_goal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::computeNextBestProxyPosition           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_goal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the next goal position of the proxy. 
<p>
Given the new position of the device and considering the current position of the proxy, this function attempts to move the proxy towards the device position (the goal). If its path is blocked by an obstacle (e.g., a triangle in a mesh), the proxy is moved to this intersection point and a new goal is calculated as the closest point to the original goal in the half-plane above the intersection triangle. The process is repeated if necessary, bringing the proxy to its final location.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_goal</em>&nbsp;</td><td>The goal towards which to move the proxy, subject to constraints </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b8d938b2bef9cedceb5ad8aa66be80af"></a><!-- doxytag: member="cProxyPointForceAlgo::goalAchieved" ref="b8d938b2bef9cedceb5ad8aa66be80af" args="(const cVector3d &amp;a_proxy, const cVector3d &amp;a_goal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cProxyPointForceAlgo::goalAchieved           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_goal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test whether the proxy has reached the goal point. 
<p>
Test whether the proxy has reached the goal point, allowing for subclass- specific approximations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_goal</em>&nbsp;</td><td>The location to which we'd like to move the proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_proxy</em>&nbsp;</td><td>The current position of the proxy </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true is the proxy has effectively reached the goal </dd></dl>

</div>
</div><p>
<a class="anchor" name="324b2f8ed022284be4d364eb92c6f311"></a><!-- doxytag: member="cProxyPointForceAlgo::initialize" ref="324b2f8ed022284be4d364eb92c6f311" args="(cWorld *a_world, const cVector3d &amp;a_initialGlobalPosition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_world.html">cWorld</a> *&nbsp;</td>
          <td class="paramname"> <em>a_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_initialGlobalPosition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the algorithm. 
<p>
Initialize the algorithm, including setting the pointer to the world in which the algorithm is to operate, and setting the initial position of the device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_world</em>&nbsp;</td><td>Pointer to world in which force algorithm is operating. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_initialGlobalPosition</em>&nbsp;</td><td>Initial position of the device. </td></tr>
  </table>
</dl>

<p>Reimplemented from <a class="el" href="classc_generic_point_force_algo.html#bcd23fc9b1e236d66cff9de138efa105">cGenericPointForceAlgo</a>.</p>

</div>
</div><p>
<a class="anchor" name="332391597c8661ade770839f00e05412"></a><!-- doxytag: member="cProxyPointForceAlgo::reset" ref="332391597c8661ade770839f00e05412" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::reset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the algorithm. Set proxy position to device position. 
<p>
Reset the algorithm. Set the proxy position to the device position. 
</div>
</div><p>
<a class="anchor" name="9e27459dcd2332cd1193e86dda26dbb0"></a><!-- doxytag: member="cProxyPointForceAlgo::setEpsilonBaseValue" ref="9e27459dcd2332cd1193e86dda26dbb0" args="(double a_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::setEpsilonBaseValue           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a_value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set epsilon base value. 
<p>
Set the epsilon value which is used during geometry computation of the proxy model. 
</div>
</div><p>
<a class="anchor" name="d21e4eb103a50b318495eefeb194d3fc"></a><!-- doxytag: member="cProxyPointForceAlgo::testFrictionAndMoveProxy" ref="d21e4eb103a50b318495eefeb194d3fc" args="(const cVector3d &amp;a_goal, const cVector3d &amp;a_proxy, cVector3d &amp;a_normal, cGenericObject *a_parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::testFrictionAndMoveProxy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to move the proxy, subject to friction constraints. 
<p>
Attempt to move the proxy, subject to friction constraints. This is called from computeNextBestProxyPosition when the proxy is ready to move along a known surface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_goal</em>&nbsp;</td><td>The location to which we'd like to move the proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_proxy</em>&nbsp;</td><td>The current position of the proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_normal</em>&nbsp;</td><td>The surface normal at the obstructing surface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_parent</em>&nbsp;</td><td>The surface along which we're moving </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="05e761a70bd2a258f854e91d00cd3772"></a><!-- doxytag: member="cProxyPointForceAlgo::updateForce" ref="05e761a70bd2a258f854e91d00cd3772" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::updateForce           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute force to apply to device. 
<p>
This method uses the information computed earlier in computeNextProxyPosition() to determine the force to apply to the device. The function computes a force proportional to the distance between the positions of the proxy and the device and scaled by the average stiffness of each contact triangle. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="d8deb50730fcf140e87db3cd6704310e"></a><!-- doxytag: member="cProxyPointForceAlgo::m_epsilonInitialValue" ref="d8deb50730fcf140e87db3cd6704310e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classc_proxy_point_force_algo.html#d8deb50730fcf140e87db3cd6704310e">cProxyPointForceAlgo::m_epsilonInitialValue</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
epsilon value - used for handling numerical limits. 
<p>
To address numerical errors during geometric computation, several epsilon values are computed and used. 
</div>
</div><p>
<a class="anchor" name="d793af77ccf02c99ea32ed2a55358b9f"></a><!-- doxytag: member="cProxyPointForceAlgo::m_frictionDynHysteresisMultiplier" ref="d793af77ccf02c99ea32ed2a55358b9f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classc_proxy_point_force_algo.html#d793af77ccf02c99ea32ed2a55358b9f">cProxyPointForceAlgo::m_frictionDynHysteresisMultiplier</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dynamic friction hysteresis multiplier In CHAI's proxy, the angle computed from the coefficient is multiplied by this constant to avoid rapidly oscillating between slipping and sticking without having to turn the dynamic friction level way down. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>D:/CHAI3D/build-2-0-0/2.0.0/win32/src/forces/<a class="el" href="_c_proxy_point_force_algo_8h_source.html">CProxyPointForceAlgo.h</a><li>D:/CHAI3D/build-2-0-0/2.0.0/win32/src/forces/CProxyPointForceAlgo.cpp</ul>
</div>
<font size=-2><br><hr><b>CHAI3D 2.0.0 documentation</b><br>Please address any questions to <a href="mailto:support@chai3d.org">support@chai3d.org</a><br>
	(C) 2003-2009 - <a href="http://www.chai3d.org">CHAI 3D</a><br>
	All Rights Reserved.
