<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CHAI3D: cGenericObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cGenericObject Class Reference<br>
<small>
[<a class="el" href="group__scenegraph.html">Scenegraph</a>]</small>
</h1><!-- doxytag: class="cGenericObject" --><!-- doxytag: inherits="cGenericType" -->This class is the root of basically every render-able object in CHAI. It defines a reference frame (position and rotation) and virtual methods for rendering, which are overloaded by useful subclasses. <br>
.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_c_generic_object_8h_source.html">CGenericObject.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for cGenericObject:</div>
<div class="dynsection">
<p><center><img src="classc_generic_object__inherit__graph.png" border="0" usemap="#c_generic_object__inherit__map" alt="Inheritance graph"></center>
<map name="c_generic_object__inherit__map">
<area shape="rect" id="node5" href="classc_bitmap.html" title="This class provides functionalities to display a bitmap image." alt="" coords="347,5,416,33"><area shape="rect" id="node7" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to..." alt="" coords="345,55,417,83"><area shape="rect" id="node9" href="classc_g_e_l_world.html" title="cGELWorld implements a world to handle deformable objects within CHAI 3D." alt="" coords="337,106,425,134"><area shape="rect" id="node11" href="classc_generic_tool.html" title="cGenericTool describes a generic class to create virtual tools inside a virtual environment..." alt="" coords="333,157,429,185"><area shape="rect" id="node15" href="classc_label.html" title="This class provides functionalities to display one line of text." alt="" coords="352,207,411,235"><area shape="rect" id="node17" href="classc_light.html" title="cLight describes an OpenGL light source, generally rendered by a cWorld object, which..." alt="" coords="353,258,409,286"><area shape="rect" id="node19" href="classc_mesh.html" title="cMesh represents a collection of vertices, triangles, materials, and texture properties..." alt="" coords="352,309,411,337"><area shape="rect" id="node23" href="classc_o_d_e_generic_body.html" title="cODEGenericBody is a base class for modeling any ODE dynamic body." alt="" coords="316,359,447,387"><area shape="rect" id="node25" href="classc_o_d_e_world.html" title="cODEWorld implements a virtual world to handle ODE based objects (cODEGenericBody)..." alt="" coords="336,410,427,438"><area shape="rect" id="node27" href="classc_shape_line.html" title="cShapeLine describes a simple line potential field" alt="" coords="337,461,425,489"><area shape="rect" id="node29" href="classc_shape_sphere.html" title="Implementation of a virtual sphere shape." alt="" coords="328,511,435,539"><area shape="rect" id="node31" href="classc_shape_torus.html" title="cShapeTorus describes a simple torus potential field." alt="" coords="333,562,429,590"><area shape="rect" id="node33" href="classc_world.html" title="cWorld defines the typical root of the CHAI scene graph. It stores lights, allocates..." alt="" coords="351,613,412,641"><area shape="rect" id="node2" href="classc_generic_type.html" title="Definition of an abstract type." alt="" coords="5,309,107,337"><area shape="rect" id="node13" href="classc_generic3dof_pointer.html" title="cGeneric3dofPointer represents a haptic tool that can apply forces in three degrees..." alt="" coords="496,157,635,185"><area shape="rect" id="node21" href="classc_g_e_l_mesh.html" title="cGELMesh inherits from cMesh and integrate a skeleton model for deformation simulation..." alt="" coords="523,309,608,337"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classc_generic_object-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="422566b11cfee02a4db559c288fedd58"></a><!-- doxytag: member="cGenericObject::cGenericObject" ref="422566b11cfee02a4db559c288fedd58" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#422566b11cfee02a4db559c288fedd58">cGenericObject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#587289693b38360ecc66684ec94c9209">~cGenericObject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>.  <a href="#587289693b38360ecc66684ec94c9209"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4732065b0fa9c9e7200b706fe8b23ddd"></a><!-- doxytag: member="cGenericObject::setPos" ref="4732065b0fa9c9e7200b706fe8b23ddd" args="(const cVector3d &amp;a_pos)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#4732065b0fa9c9e7200b706fe8b23ddd">setPos</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local position of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="509690041713dbb4d93ff29361cc74f1"></a><!-- doxytag: member="cGenericObject::setPos" ref="509690041713dbb4d93ff29361cc74f1" args="(const double a_x, const double a_y, const double a_z)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#509690041713dbb4d93ff29361cc74f1">setPos</a> (const double a_x, const double a_y, const double a_z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local position of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="81a5594469dfd53b13069ac851e51252"></a><!-- doxytag: member="cGenericObject::getPos" ref="81a5594469dfd53b13069ac851e51252" args="() const " -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#81a5594469dfd53b13069ac851e51252">getPos</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local position of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46ce5f77b1b96c913644320725f7d6f1"></a><!-- doxytag: member="cGenericObject::getGlobalPos" ref="46ce5f77b1b96c913644320725f7d6f1" args="() const " -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#46ce5f77b1b96c913644320725f7d6f1">getGlobalPos</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the global position of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d8389b7ae9cb1d9cd7b9952fa16ac156"></a><!-- doxytag: member="cGenericObject::setRot" ref="d8389b7ae9cb1d9cd7b9952fa16ac156" args="(const cMatrix3d &amp;a_rot)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d8389b7ae9cb1d9cd7b9952fa16ac156">setRot</a> (const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;a_rot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local rotation matrix for this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16d812a4d2b83a0718da5f94a53aed4"></a><!-- doxytag: member="cGenericObject::getRot" ref="a16d812a4d2b83a0718da5f94a53aed4" args="() const " -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#a16d812a4d2b83a0718da5f94a53aed4">getRot</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local rotation matrix of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2509c6687ab7301bf9889ae3bd36759"></a><!-- doxytag: member="cGenericObject::getGlobalRot" ref="e2509c6687ab7301bf9889ae3bd36759" args="() const " -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#e2509c6687ab7301bf9889ae3bd36759">getGlobalRot</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the global rotation matrix of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b08a1331c6217e833acf95466799962f">translate</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_translation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate this object by a specified offset.  <a href="#b08a1331c6217e833acf95466799962f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#92df52ff262a682849a1e572393ff9b4">translate</a> (const double a_x, const double a_y, const double a_z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate this object by a specified offset.  <a href="#92df52ff262a682849a1e572393ff9b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#bba165a0395766782e2dbe7735efe8a9">rotate</a> (const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;a_rotation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate this object by multiplying with a specified rotation matrix.  <a href="#bba165a0395766782e2dbe7735efe8a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f9b82697b12cefa4a9601a45e055f8cb">rotate</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_axis, const double a_angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate this object around axis a_axis by angle a_angle (radians).  <a href="#f9b82697b12cefa4a9601a45e055f8cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ab21f63a5cf247f607158ca1e7422617">computeGlobalPositions</a> (const bool a_frameOnly=true, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_globalPos=<a class="el" href="structc_vector3d.html">cVector3d</a>(0.0, 0.0, 0.0), const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;a_globalRot=cIdentity3d())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the global position and rotation of this object and its children.  <a href="#ab21f63a5cf247f607158ca1e7422617"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#af669adcf2a807bc30b5298b6985f24f">computeGlobalCurrentObjectOnly</a> (const bool a_frameOnly=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the global position and rotation of current object only.  <a href="#af669adcf2a807bc30b5298b6985f24f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="da36eb6b2a68cd6fb2f7ef3da7127a6a"></a><!-- doxytag: member="cGenericObject::computeGlobalPositionsAndMotion" ref="da36eb6b2a68cd6fb2f7ef3da7127a6a" args="(const bool a_frameOnly=true, const cVector3d &amp;a_globalPos=cVector3d(0.0, 0.0, 0.0), const cMatrix3d &amp;a_globalRot=cIdentity3d())" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#da36eb6b2a68cd6fb2f7ef3da7127a6a">computeGlobalPositionsAndMotion</a> (const bool a_frameOnly=true, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_globalPos=<a class="el" href="structc_vector3d.html">cVector3d</a>(0.0, 0.0, 0.0), const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;a_globalRot=cIdentity3d())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the global position and rotation with relative motion of this object and its children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#473fcf59972cb7fa9c0d4eef29317c4a">computeInteractions</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolPos, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolVel, const unsigned int a_IDN, <a class="el" href="classc_interaction_recorder.html">cInteractionRecorder</a> &amp;a_interactions, <a class="el" href="structc_interaction_settings.html">cInteractionSettings</a> &amp;a_interactionSettings)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6be6f5bd0b76c89dd5d5f995b7392554">addEffect</a> (<a class="el" href="classc_generic_effect.html">cGenericEffect</a> *a_newEffect)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add an effect.  <a href="#6be6f5bd0b76c89dd5d5f995b7392554"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#7d9e7359d3709477e58e5d22c65bb23d">setStiffness</a> (double a_stiffness, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the haptic stiffness, possibly recursively affecting children.  <a href="#7d9e7359d3709477e58e5d22c65bb23d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d58d996e3ff702f26f80a14580982e05">setFriction</a> (double a_staticFriction, double a_dynamicFriction, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the static and dynamic friction for this mesh, possibly recursively affecting children.  <a href="#d58d996e3ff702f26f80a14580982e05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#089981024cc3376c7b00c3c6df9d70f3">setShowEnabled</a> (const bool a_show, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide this object, optionally propagating the change to children.  <a href="#089981024cc3376c7b00c3c6df9d70f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b02d5cb5ec7347e2005f3464eea9b719"></a><!-- doxytag: member="cGenericObject::getShowEnabled" ref="b02d5cb5ec7347e2005f3464eea9b719" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b02d5cb5ec7347e2005f3464eea9b719">getShowEnabled</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of object (true means it's visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6c9067771330437a4906eb90e45db334">setHapticEnabled</a> (const bool a_hapticEnabled, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow this object to be felt (when visible), optionally propagating the change to children.  <a href="#6c9067771330437a4906eb90e45db334"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d6e2b990d4778dd4d6296df63c07ebdf"></a><!-- doxytag: member="cGenericObject::getHapticEnabled" ref="d6e2b990d4778dd4d6296df63c07ebdf" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d6e2b990d4778dd4d6296df63c07ebdf">getHapticEnabled</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the haptic status of object (true means it can be felt when visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#363edb61b70cd06722a7b9d9594da1da">setShowTree</a> (const bool a_showTree, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide the child/parent tree, optionally propagating the change to children.  <a href="#363edb61b70cd06722a7b9d9594da1da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53e48c6e48e3bfb1d73105a10717f14b"></a><!-- doxytag: member="cGenericObject::getShowTree" ref="53e48c6e48e3bfb1d73105a10717f14b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#53e48c6e48e3bfb1d73105a10717f14b">getShowTree</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of the tree (true means it's visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ec8f42b031fb0140633b5cb73e16094b">setTreeColor</a> (const <a class="el" href="structc_colorf.html">cColorf</a> &amp;a_treeColor, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the tree color, optionally propagating the change to children.  <a href="#ec8f42b031fb0140633b5cb73e16094b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2416737096f2d5b08ced719317764bd8"></a><!-- doxytag: member="cGenericObject::getTreeColor" ref="2416737096f2d5b08ced719317764bd8" args="() const " -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#2416737096f2d5b08ced719317764bd8">getTreeColor</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the tree color. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#645192ff03d772d141a2e391fe355910">setShowFrame</a> (const bool a_showFrame, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide the reference frame arrows for this object, optionally propagating the change to children.  <a href="#645192ff03d772d141a2e391fe355910"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8ce30b90ea019105185b24e4ecdf626"></a><!-- doxytag: member="cGenericObject::getShowFrame" ref="a8ce30b90ea019105185b24e4ecdf626" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#a8ce30b90ea019105185b24e4ecdf626">getShowFrame</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of the reference frame (true means it's visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#3d1b3334e5dcb92ff585694f1b18d7f7">setShowBox</a> (const bool iShowBox, const bool iAffectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide the boundary box for this object, optionally propagating the change to children.  <a href="#3d1b3334e5dcb92ff585694f1b18d7f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d866a665a681a803d0831a41b3fa507a"></a><!-- doxytag: member="cGenericObject::getShowBox" ref="d866a665a681a803d0831a41b3fa507a" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d866a665a681a803d0831a41b3fa507a">getShowBox</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of boundary box. (true means it's visible). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#36189f1d90cb10cbddb429d5789eef9f">setBoxColor</a> (const <a class="el" href="structc_colorf.html">cColorf</a> &amp;a_boxColor, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the color of boundary box for this object, optionally propagating the change to children.  <a href="#36189f1d90cb10cbddb429d5789eef9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a04aa07f4ab2acbe4e27f96b5948d0d"></a><!-- doxytag: member="cGenericObject::getBoxColor" ref="2a04aa07f4ab2acbe4e27f96b5948d0d" args="() const " -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#2a04aa07f4ab2acbe4e27f96b5948d0d">getBoxColor</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the color of boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c229037462e3526453d37ae7136ea93a">setShowCollisionTree</a> (const bool a_showCollisionTree, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide the collision tree for this object, optionally propagating the change to children.  <a href="#c229037462e3526453d37ae7136ea93a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d5a2eb4f32104a9d30d221713703602"></a><!-- doxytag: member="cGenericObject::getShowCollisionTree" ref="5d5a2eb4f32104a9d30d221713703602" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5d5a2eb4f32104a9d30d221713703602">getShowCollisionTree</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the display status of of the collision tree for this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#bceaa39ca365c7092d4b3932665439d8">onDisplayReset</a> (const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should get called when it's necessary to re-initialize the OpenGL context.  <a href="#bceaa39ca365c7092d4b3932665439d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ca3d6fc97084c2ab439d2486d98e23e6">finalize</a> (const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function tells children that you're not going to change their contents any more.  <a href="#ca3d6fc97084c2ab439d2486d98e23e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c6bf258cebfd460192b3a1383266ea95">unfinalize</a> (const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function tells objects that you may modify their contents.  <a href="#c6bf258cebfd460192b3a1383266ea95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f5189d2e6a0456c2d5f257ca8bdf360a">renderSceneGraph</a> (const int a_renderMode=CHAI_RENDER_MODE_RENDER_ALL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render the entire scene graph, starting from this object.  <a href="#f5189d2e6a0456c2d5f257ca8bdf360a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#27083888fdfd8e055131f3842967d7f0">setMaterial</a> (<a class="el" href="structc_material.html">cMaterial</a> &amp;a_mat, const bool a_affectChildren=false, const bool a_applyPhysicalParmetersOnly=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the material for this mesh, and optionally pass it on to my children.  <a href="#27083888fdfd8e055131f3842967d7f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b7c8b442fc3acc50374df2f0f678e696">setTransparencyLevel</a> (const float a_level, const bool a_applyToTextures=false, const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the alpha value at each vertex and in all of my material colors.  <a href="#b7c8b442fc3acc50374df2f0f678e696"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#86c7c6188ea7bb40691081ce65b61123">setTransparencyRenderMode</a> (const bool a_useMultipassTransparency, const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify whether this mesh should use multipass transparency (see <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a>).  <a href="#86c7c6188ea7bb40691081ce65b61123"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="563ab36bfb664fa7b1f6cc389cde4e6b"></a><!-- doxytag: member="cGenericObject::getMultipassTransparencyEnabled" ref="563ab36bfb664fa7b1f6cc389cde4e6b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#563ab36bfb664fa7b1f6cc389cde4e6b">getMultipassTransparencyEnabled</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is multipass transparency used for this mesh? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#9d463f2aa2d54ab5b56a9aa99b65807a">setUseTransparency</a> (const bool a_useTransparency, const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable transparency (also see setTransparencyRenderMode)... turns the depth mask _off_!  <a href="#9d463f2aa2d54ab5b56a9aa99b65807a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a313b0cf1dba52c4b2f379bcb81951c1"></a><!-- doxytag: member="cGenericObject::getUseTransparency" ref="a313b0cf1dba52c4b2f379bcb81951c1" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#a313b0cf1dba52c4b2f379bcb81951c1">getUseTransparency</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is transparency enabled for this mesh? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#42738805cabe3bd0f44f49b794ce0ef5">setWireMode</a> (const bool a_showWireMode, const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable wireframe rendering, optionally propagating the operation to my children.  <a href="#42738805cabe3bd0f44f49b794ce0ef5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca2843a8532c806cee8760873241e756"></a><!-- doxytag: member="cGenericObject::getWireMode" ref="ca2843a8532c806cee8760873241e756" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ca2843a8532c806cee8760873241e756">getWireMode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether wireframe rendering is enabled. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#44fd98520ccf092e2ba5299ddec2c248">setUseCulling</a> (const bool a_useCulling, const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disabling face-culling, optionally propagating the operation to my children.  <a href="#44fd98520ccf092e2ba5299ddec2c248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1932a3f9eaaeeb741400c2b4bb35b053"></a><!-- doxytag: member="cGenericObject::getUseCulling" ref="1932a3f9eaaeeb741400c2b4bb35b053" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#1932a3f9eaaeeb741400c2b4bb35b053">getUseCulling</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is face-culling currently enabled? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#54e26549e25f2f11c56ec2dbfc0a591a">setUseVertexColors</a> (const bool a_useColors, const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable the use of per-vertex colors, optionally propagating the operation to my children.  <a href="#54e26549e25f2f11c56ec2dbfc0a591a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e212796b55d675a9664ad7d1630fe446"></a><!-- doxytag: member="cGenericObject::getUseVertexColors" ref="e212796b55d675a9664ad7d1630fe446" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#e212796b55d675a9664ad7d1630fe446">getUseVertexColors</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are per-vertex properties currently enabled? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#27ca76ab6660297f134d39f796b967d2">setUseMaterial</a> (const bool a_useMaterial, const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable the use of material properties, optionally propagating the operation to my children.  <a href="#27ca76ab6660297f134d39f796b967d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3edc61dd194a61f5230b646e79bb7818"></a><!-- doxytag: member="cGenericObject::getUseMaterial" ref="3edc61dd194a61f5230b646e79bb7818" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#3edc61dd194a61f5230b646e79bb7818">getUseMaterial</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are material properties currently enabled? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#e36467b7ef1d1d2c60933bfca3b30309">setUseTexture</a> (const bool a_useTexture, const bool a_affectChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable the use of texture-mapping, optionally propagating the operation to my children.  <a href="#e36467b7ef1d1d2c60933bfca3b30309"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc4ab7fc7a12bc33a642bd001701a281"></a><!-- doxytag: member="cGenericObject::getUseTexture" ref="cc4ab7fc7a12bc33a642bd001701a281" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#cc4ab7fc7a12bc33a642bd001701a281">getUseTexture</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is texture-mapping enabled? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6b9115557e2b23eb7f050b42fd610c19">setTexture</a> (<a class="el" href="classc_texture2_d.html">cTexture2D</a> *a_texture, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set my texture, possibly recursively affecting children.  <a href="#6b9115557e2b23eb7f050b42fd610c19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57ae8f84c7a02103f63fce3d04cb25bb"></a><!-- doxytag: member="cGenericObject::getTexture" ref="57ae8f84c7a02103f63fce3d04cb25bb" args="() const " -->
<a class="el" href="classc_texture2_d.html">cTexture2D</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#57ae8f84c7a02103f63fce3d04cb25bb">getTexture</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access my texture. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32309ff9124b9dad506280820f1ce7a7"></a><!-- doxytag: member="cGenericObject::getBoundaryMin" ref="32309ff9124b9dad506280820f1ce7a7" args="() const " -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#32309ff9124b9dad506280820f1ce7a7">getBoundaryMin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the minimum point of this object's boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ddaa9528bd6674aa680eef67ccf4d15e"></a><!-- doxytag: member="cGenericObject::getBoundaryMax" ref="ddaa9528bd6674aa680eef67ccf4d15e" args="() const " -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ddaa9528bd6674aa680eef67ccf4d15e">getBoundaryMax</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the maximum point of this object's boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c917b5d055198ed70681216743bb1c80"></a><!-- doxytag: member="cGenericObject::getBoundaryCenter" ref="c917b5d055198ed70681216743bb1c80" args="() const " -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c917b5d055198ed70681216743bb1c80">getBoundaryCenter</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the center of this object's boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#152b67a212d8f359ec7a24d2c8be7a33">computeBoundaryBox</a> (const bool a_includeChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-compute this object's bounding box, optionally forcing it to bound child objects.  <a href="#152b67a212d8f359ec7a24d2c8be7a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c43081628c7ae8577dcb270983eea2e6">setFrameSize</a> (const double a_size=1.0, const double a_thickness=1.0, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the size of the rendered reference frame, optionally propagating the change to children.  <a href="#c43081628c7ae8577dcb270983eea2e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5433cba429c78f605aacf4b61a3cf83d"></a><!-- doxytag: member="cGenericObject::getFrameSize" ref="5433cba429c78f605aacf4b61a3cf83d" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5433cba429c78f605aacf4b61a3cf83d">getFrameSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the size of the rendered reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca06014fb45dd2cf7e8c71b2b8062dbf"></a><!-- doxytag: member="cGenericObject::setCollisionDetector" ref="ca06014fb45dd2cf7e8c71b2b8062dbf" args="(cGenericCollision *a_collisionDetector)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ca06014fb45dd2cf7e8c71b2b8062dbf">setCollisionDetector</a> (<a class="el" href="classc_generic_collision.html">cGenericCollision</a> *a_collisionDetector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a collision detector for current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eca558d728c94d42ddd2b5f8420082b3"></a><!-- doxytag: member="cGenericObject::getCollisionDetector" ref="eca558d728c94d42ddd2b5f8420082b3" args="() const " -->
<a class="el" href="classc_generic_collision.html">cGenericCollision</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#eca558d728c94d42ddd2b5f8420082b3">getCollisionDetector</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get pointer to this object's current collision detector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#22abb35355c5be8622be3cac2e6fb510">setCollisionDetectorProperties</a> (unsigned int a_displayDepth, <a class="el" href="structc_colorf.html">cColorf</a> &amp;a_color, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set collision rendering properties.  <a href="#22abb35355c5be8622be3cac2e6fb510"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#e923e09ba8708ecc49f423f0ef68fba8">deleteCollisionDetector</a> (const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete any existing collision detector and set the current cd to null (no collisions).  <a href="#e923e09ba8708ecc49f423f0ef68fba8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#47ed11f450db33671dbf27f12ffe1bcc">computeCollisionDetection</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointA, <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointB, <a class="el" href="classc_collision_recorder.html">cCollisionRecorder</a> &amp;a_recorder, <a class="el" href="structc_collision_settings.html">cCollisionSettings</a> &amp;a_settings)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute collision detection using collision trees.  <a href="#47ed11f450db33671dbf27f12ffe1bcc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d7204c3654f82aa86599befff4b23aae">adjustCollisionSegment</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointA, <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointAadjusted)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust collision segment for dynamic objects.  <a href="#d7204c3654f82aa86599befff4b23aae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="51a5d8aa0d5bf31e3a1e018d6421de66"></a><!-- doxytag: member="cGenericObject::setParent" ref="51a5d8aa0d5bf31e3a1e018d6421de66" args="(cGenericObject *a_parent)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#51a5d8aa0d5bf31e3a1e018d6421de66">setParent</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set parent of current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b7826e817e427b4883ff7c0ff7cad96"></a><!-- doxytag: member="cGenericObject::getParent" ref="1b7826e817e427b4883ff7c0ff7cad96" args="() const " -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#1b7826e817e427b4883ff7c0ff7cad96">getParent</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read parent of current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09f6d7d1fde9cda79b43dd9008818014"></a><!-- doxytag: member="cGenericObject::getChild" ref="09f6d7d1fde9cda79b43dd9008818014" args="(const unsigned int a_index) const " -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#09f6d7d1fde9cda79b43dd9008818014">getChild</a> (const unsigned int a_index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an object from my list of children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#84e3f5d5cd786a987c77ed19eed4c054">addChild</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an object to my list of children.  <a href="#84e3f5d5cd786a987c77ed19eed4c054"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#90e5033f96dc1e891cac79e5e56e1424">removeChild</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an object from my list of children, without deleting it.  <a href="#90e5033f96dc1e891cac79e5e56e1424"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d54d4284c0ca71d2e199080bc3559878">containsChild</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object, bool a_includeChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this object have the specified object as a child?  <a href="#d54d4284c0ca71d2e199080bc3559878"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b612f2a2121062bd70b1096bc51a6895">deleteChild</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an object from my list of children and delete it.  <a href="#b612f2a2121062bd70b1096bc51a6895"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f56e64f9db66bc82e51c44e756e13495"></a><!-- doxytag: member="cGenericObject::clearAllChildren" ref="f56e64f9db66bc82e51c44e756e13495" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f56e64f9db66bc82e51c44e756e13495">clearAllChildren</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all objects from my list of children, without deleting them. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#a1552a230244d2119043026e03aef8f2">deleteAllChildren</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear and delete all objects from my list of children.  <a href="#a1552a230244d2119043026e03aef8f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f5b57d4b83926f1593bc051c0eda07e9"></a><!-- doxytag: member="cGenericObject::getNumChildren" ref="f5b57d4b83926f1593bc051c0eda07e9" args="()" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f5b57d4b83926f1593bc051c0eda07e9">getNumChildren</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of children on my list of children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#746f4083ff824c30a246cd01c17893a1">getNumDescendants</a> (bool a_includeCurrentObject=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return my total number of descendants, optionally including this object.  <a href="#746f4083ff824c30a246cd01c17893a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#58001a089d78289dde9adfc2403a6a62">enumerateChildren</a> (std::list&lt; <a class="el" href="classc_generic_object.html">cGenericObject</a> * &gt; &amp;a_childList, bool a_includeCurrentObject=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill this list with all of my descendants.  <a href="#58001a089d78289dde9adfc2403a6a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6642e18832667bd51ef98432e8966b85"></a><!-- doxytag: member="cGenericObject::removeFromGraph" ref="6642e18832667bd51ef98432e8966b85" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6642e18832667bd51ef98432e8966b85">removeFromGraph</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove me from my parent's CHAI scene graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#01f651983f2be2211fbb97b2e1c40f3b">setAsGhost</a> (bool a_ghostStatus)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes this object a ghost node.  <a href="#01f651983f2be2211fbb97b2e1c40f3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1e3a9f839fb649cbd7d244254659daf"></a><!-- doxytag: member="cGenericObject::getAsGhost" ref="d1e3a9f839fb649cbd7d244254659daf" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d1e3a9f839fb649cbd7d244254659daf">getAsGhost</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the ghost status of this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b77f1daab7169e2663f2c2b32135fbb5">setExternalParent</a> (<a class="el" href="classc_generic_type.html">cGenericType</a> *a_externalParent, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a pointer to an external parent of the current object. Optionally propagating the change to children.  <a href="#b77f1daab7169e2663f2c2b32135fbb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96e3747e3ff3ae097287f51a5a6a0039"></a><!-- doxytag: member="cGenericObject::getExternalParent" ref="96e3747e3ff3ae097287f51a5a6a0039" args="()" -->
<a class="el" href="classc_generic_type.html">cGenericType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#96e3747e3ff3ae097287f51a5a6a0039">getExternalParent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the external parent of current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#c49958287cc1bd7fbd28b1101445e839">setSuperParent</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_superParent, const bool a_affectChildren=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the super parent of the current object. Optionally propagating the change to children.  <a href="#c49958287cc1bd7fbd28b1101445e839"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb12da762f94c2efcc68f6627955aeef"></a><!-- doxytag: member="cGenericObject::getSuperParent" ref="cb12da762f94c2efcc68f6627955aeef" args="()" -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#cb12da762f94c2efcc68f6627955aeef">getSuperParent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the super parent of current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#9be8abb917b1f84e5196c0213aca1617">scale</a> (const double &amp;a_scaleFactor, const bool a_includeChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale this object by a_scaleFactor (uniform scale).  <a href="#9be8abb917b1f84e5196c0213aca1617"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#8bdcfa16951b6da2f8c6f0b95d2d9500">scale</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_scaleFactors, const bool a_includeChildren=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-uniform scale.  <a href="#8bdcfa16951b6da2f8c6f0b95d2d9500"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#001853c55875d15fc535f6806ac0b47b">setTag</a> (const int a_tag, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the tag for this object and - optionally - for my children.  <a href="#001853c55875d15fc535f6806ac0b47b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#af6da87dec3f13c00fd338ea9af1c9fc">setUserData</a> (void *a_data, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the m_userData pointer for this object and - optionally - for my children.  <a href="#af6da87dec3f13c00fd338ea9af1c9fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#8a1cce0f5d34a968da81bcb54524e8b1">setName</a> (const char *a_name, const bool a_affectChildren=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name for this object and - optionally - for my children.  <a href="#8a1cce0f5d34a968da81bcb54524e8b1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="084fb35d1c9b3544ae7d7169c4ddbb90"></a><!-- doxytag: member="cGenericObject::m_interactionProjectedPoint" ref="084fb35d1c9b3544ae7d7169c4ddbb90" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#084fb35d1c9b3544ae7d7169c4ddbb90">m_interactionProjectedPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Projection of the latest interaction point with the surface (limits) of the current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="947606e46b0918aa42e83c3ce2980f9e"></a><!-- doxytag: member="cGenericObject::m_interactionInside" ref="947606e46b0918aa42e83c3ce2980f9e" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#947606e46b0918aa42e83c3ce2980f9e">m_interactionInside</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Was the last interaction point located inside the object? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4026e2eafc84505cff2451021c62cdae"></a><!-- doxytag: member="cGenericObject::m_effects" ref="4026e2eafc84505cff2451021c62cdae" args="" -->
vector&lt; <a class="el" href="classc_generic_effect.html">cGenericEffect</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#4026e2eafc84505cff2451021c62cdae">m_effects</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list of haptic effects. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cfed25ea44b3fe49dd71e1e05c6470ad"></a><!-- doxytag: member="cGenericObject::m_material" ref="cfed25ea44b3fe49dd71e1e05c6470ad" args="" -->
<a class="el" href="structc_material.html">cMaterial</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#cfed25ea44b3fe49dd71e1e05c6470ad">m_material</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Material properties. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10b4e6a9bbb6379e856fd5af26099eb8"></a><!-- doxytag: member="cGenericObject::m_texture" ref="10b4e6a9bbb6379e856fd5af26099eb8" args="" -->
<a class="el" href="classc_texture2_d.html">cTexture2D</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#10b4e6a9bbb6379e856fd5af26099eb8">m_texture</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Texture property. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9257da1a0aa43080bf706545e004c3f0"></a><!-- doxytag: member="cGenericObject::m_tag" ref="9257da1a0aa43080bf706545e004c3f0" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#9257da1a0aa43080bf706545e004c3f0">m_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An arbitrary tag, not used by CHAI. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="184b30efc8533834ab7d33cc5688b625"></a><!-- doxytag: member="cGenericObject::m_userData" ref="184b30efc8533834ab7d33cc5688b625" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#184b30efc8533834ab7d33cc5688b625">m_userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An arbitrary data pointer, not used by CHAI. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e0844ef15138d46fa3fec68cbf11445"></a><!-- doxytag: member="cGenericObject::m_objectName" ref="9e0844ef15138d46fa3fec68cbf11445" args="[CHAI_SIZE_NAME]" -->
char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#9e0844ef15138d46fa3fec68cbf11445">m_objectName</a> [CHAI_SIZE_NAME]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A name for this object, automatically assigned by mesh loaders (for example). <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#7eb87a0e7dd896f081854e693e4f60d9">render</a> (const int a_renderMode=CHAI_RENDER_MODE_RENDER_ALL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render this object in OpenGL.  <a href="#7eb87a0e7dd896f081854e693e4f60d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0e5d7ce19ae357176f0f407626a80f8"></a><!-- doxytag: member="cGenericObject::updateGlobalPositions" ref="f0e5d7ce19ae357176f0f407626a80f8" args="(const bool a_frameOnly)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f0e5d7ce19ae357176f0f407626a80f8">updateGlobalPositions</a> (const bool a_frameOnly)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the m_globalPos and m_globalRot properties of any members of this object (e.g. all triangles). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d5fff8fb9e5b6ecff89b29efaed9ca1"></a><!-- doxytag: member="cGenericObject::updateBoundaryBox" ref="0d5fff8fb9e5b6ecff89b29efaed9ca1" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#0d5fff8fb9e5b6ecff89b29efaed9ca1">updateBoundaryBox</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the bounding box of this object, based on object-specific data (e.g. triangle positions). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c647d27f4e9f308dbf5db2af56fab17"></a><!-- doxytag: member="cGenericObject::scaleObject" ref="5c647d27f4e9f308dbf5db2af56fab17" args="(const cVector3d &amp;a_scaleFactors)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5c647d27f4e9f308dbf5db2af56fab17">scaleObject</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_scaleFactors)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale current object with scale factors along x, y and z. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f80fcd6a2dd14d167b82b7cbda9a43dd">computeLocalInteraction</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolPos, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolVel, const unsigned int a_IDN)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the geometric relationship between the tool and the current object.  <a href="#f80fcd6a2dd14d167b82b7cbda9a43dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55b03221cc74ebdecc441908a56f0823"></a><!-- doxytag: member="cGenericObject::computeOtherInteractions" ref="55b03221cc74ebdecc441908a56f0823" args="(const cVector3d &amp;a_toolPos, const cVector3d &amp;a_toolVel, const unsigned int a_IDN, cInteractionRecorder &amp;a_interactions, cInteractionSettings &amp;a_interactionSettings)" -->
virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#55b03221cc74ebdecc441908a56f0823">computeOtherInteractions</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolPos, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolVel, const unsigned int a_IDN, <a class="el" href="classc_interaction_recorder.html">cInteractionRecorder</a> &amp;a_interactions, <a class="el" href="structc_interaction_settings.html">cInteractionSettings</a> &amp;a_interactionSettings)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes any other interaction with object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="644e8cbe3c51d43ba172aa9463aa51b0"></a><!-- doxytag: member="cGenericObject::computeOtherCollisionDetection" ref="644e8cbe3c51d43ba172aa9463aa51b0" args="(cVector3d &amp;a_segmentPointA, cVector3d &amp;a_segmentPointB, cCollisionRecorder &amp;a_recorder, cCollisionSettings &amp;a_settings)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#644e8cbe3c51d43ba172aa9463aa51b0">computeOtherCollisionDetection</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointA, <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointB, <a class="el" href="classc_collision_recorder.html">cCollisionRecorder</a> &amp;a_recorder, <a class="el" href="structc_collision_settings.html">cCollisionSettings</a> &amp;a_settings)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute any collisions other than the default collision detector. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="42ed6c65ea4f0fc7bbe4cfd5ddb0f989"></a><!-- doxytag: member="cGenericObject::m_parent" ref="42ed6c65ea4f0fc7bbe4cfd5ddb0f989" args="" -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#42ed6c65ea4f0fc7bbe4cfd5ddb0f989">m_parent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parent object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ffbf37ddc31306fe97dad8dc5e66c7d2"></a><!-- doxytag: member="cGenericObject::m_children" ref="ffbf37ddc31306fe97dad8dc5e66c7d2" args="" -->
vector&lt; <a class="el" href="classc_generic_object.html">cGenericObject</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ffbf37ddc31306fe97dad8dc5e66c7d2">m_children</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">My list of children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c9eb509401a1410076106b0db57f3ca"></a><!-- doxytag: member="cGenericObject::m_ghostStatus" ref="5c9eb509401a1410076106b0db57f3ca" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5c9eb509401a1410076106b0db57f3ca">m_ghostStatus</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ghost status of current object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc_generic_type.html">cGenericType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d751b0a72776192a9775dbbb0bd1f07a">m_externalParent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#a2eeb07fed010a22852eafa9bd030f62">m_superParent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="995b36bda97019f7914d9253de907dfe"></a><!-- doxytag: member="cGenericObject::m_localPos" ref="995b36bda97019f7914d9253de907dfe" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#995b36bda97019f7914d9253de907dfe">m_localPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The position of this object in my parent's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="17d87fe53dc0b438bf8d1a993f6c33e3"></a><!-- doxytag: member="cGenericObject::m_globalPos" ref="17d87fe53dc0b438bf8d1a993f6c33e3" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#17d87fe53dc0b438bf8d1a993f6c33e3">m_globalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The position of this object in the world's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a7000a221c523d46dc84d7a6f4c0cd6"></a><!-- doxytag: member="cGenericObject::m_localRot" ref="9a7000a221c523d46dc84d7a6f4c0cd6" args="" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#9a7000a221c523d46dc84d7a6f4c0cd6">m_localRot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rotation matrix that rotates my reference frame into my parent's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5a08fdb16af899fb92e7be839292b097"></a><!-- doxytag: member="cGenericObject::m_globalRot" ref="5a08fdb16af899fb92e7be839292b097" args="" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#5a08fdb16af899fb92e7be839292b097">m_globalRot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rotation matrix that rotates my reference frame into the world's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3932c53cd7a1887e2b974fbc8dc7226f"></a><!-- doxytag: member="cGenericObject::m_prevLocalPos" ref="3932c53cd7a1887e2b974fbc8dc7226f" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#3932c53cd7a1887e2b974fbc8dc7226f">m_prevLocalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The previous position of this of this object in the parent's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57b089222e4b7fe04c06bff7f628f8b8"></a><!-- doxytag: member="cGenericObject::m_prevLocalRot" ref="57b089222e4b7fe04c06bff7f628f8b8" args="" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#57b089222e4b7fe04c06bff7f628f8b8">m_prevLocalRot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The previous position of this of this object in the parent's reference frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b51b6cdb33c18e2653fd6941ac336638"></a><!-- doxytag: member="cGenericObject::m_prevGlobalPos" ref="b51b6cdb33c18e2653fd6941ac336638" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b51b6cdb33c18e2653fd6941ac336638">m_prevGlobalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A previous position; exact interpretation up to user. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8e5a2c395b85eb8634ea4b8080c328c9"></a><!-- doxytag: member="cGenericObject::m_prevGlobalRot" ref="8e5a2c395b85eb8634ea4b8080c328c9" args="" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#8e5a2c395b85eb8634ea4b8080c328c9">m_prevGlobalRot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A previous rotation; exact interpretation up to user. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6bcf652fb1e4cfdccd5d7d8d5778734f"></a><!-- doxytag: member="cGenericObject::m_boundaryBoxMin" ref="6bcf652fb1e4cfdccd5d7d8d5778734f" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6bcf652fb1e4cfdccd5d7d8d5778734f">m_boundaryBoxMin</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum position of boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="149f973696bc569e4b1aa0a985bba23e"></a><!-- doxytag: member="cGenericObject::m_boundaryBoxMax" ref="149f973696bc569e4b1aa0a985bba23e" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#149f973696bc569e4b1aa0a985bba23e">m_boundaryBoxMax</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum position of boundary box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52b37b8bb3f723987881ac0ff81d954a"></a><!-- doxytag: member="cGenericObject::m_frameSize" ref="52b37b8bb3f723987881ac0ff81d954a" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#52b37b8bb3f723987881ac0ff81d954a">m_frameSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of graphical representation of frame (X-Y-Z). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fdc82e92bc35351885e3555555701602"></a><!-- doxytag: member="cGenericObject::m_frameThicknessScale" ref="fdc82e92bc35351885e3555555701602" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#fdc82e92bc35351885e3555555701602">m_frameThicknessScale</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pen thickness of graphical representation of frame (X-Y-Z). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a93045f0fa3c3f271b00fbd942a95c9"></a><!-- doxytag: member="cGenericObject::m_show" ref="4a93045f0fa3c3f271b00fbd942a95c9" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#4a93045f0fa3c3f271b00fbd942a95c9">m_show</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, this object is rendered. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6e8808407cc75bf3dbee02dcadd2ae64"></a><!-- doxytag: member="cGenericObject::m_hapticEnabled" ref="6e8808407cc75bf3dbee02dcadd2ae64" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#6e8808407cc75bf3dbee02dcadd2ae64">m_hapticEnabled</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IF <b>true</b>, this object can be felt. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f44c458872b98a634008a52318fae9ef"></a><!-- doxytag: member="cGenericObject::m_showFrame" ref="f44c458872b98a634008a52318fae9ef" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#f44c458872b98a634008a52318fae9ef">m_showFrame</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, this object's reference frame is rendered as a set of arrows. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25c2acb8ea52ebf30ee1b9eff3ac294d"></a><!-- doxytag: member="cGenericObject::m_showBox" ref="25c2acb8ea52ebf30ee1b9eff3ac294d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#25c2acb8ea52ebf30ee1b9eff3ac294d">m_showBox</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, this object's boundary box is displayed as a set of lines. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d04599aea8b9caa56dd2335f9afc8e36"></a><!-- doxytag: member="cGenericObject::m_showTree" ref="d04599aea8b9caa56dd2335f9afc8e36" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#d04599aea8b9caa56dd2335f9afc8e36">m_showTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, the skeleton of the scene graph is rendered at this node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b28ca5f27ab6accbaf7ebf22a80cba24"></a><!-- doxytag: member="cGenericObject::m_showCollisionTree" ref="b28ca5f27ab6accbaf7ebf22a80cba24" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b28ca5f27ab6accbaf7ebf22a80cba24">m_showCollisionTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, the collision tree is displayed (if available) at this node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c9749673419d6ea51ae89bd8f5df8c0"></a><!-- doxytag: member="cGenericObject::m_treeColor" ref="3c9749673419d6ea51ae89bd8f5df8c0" args="" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#3c9749673419d6ea51ae89bd8f5df8c0">m_treeColor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The color of the collision tree. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b76bfe86033c2692ecde47afc1e19997"></a><!-- doxytag: member="cGenericObject::m_boundaryBoxColor" ref="b76bfe86033c2692ecde47afc1e19997" args="" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#b76bfe86033c2692ecde47afc1e19997">m_boundaryBoxColor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The color of the bounding box. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36a5b2e1d1cab407949f0511cca076dc"></a><!-- doxytag: member="cGenericObject::m_useTextureMapping" ref="36a5b2e1d1cab407949f0511cca076dc" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#36a5b2e1d1cab407949f0511cca076dc">m_useTextureMapping</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should texture mapping be used? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7c15080fd4260f376ae1a6045670fd1c"></a><!-- doxytag: member="cGenericObject::m_useMaterialProperty" ref="7c15080fd4260f376ae1a6045670fd1c" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#7c15080fd4260f376ae1a6045670fd1c">m_useMaterialProperty</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should material properties be used? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bdcd2bc8e6792d0208435552579e48fb"></a><!-- doxytag: member="cGenericObject::m_useVertexColors" ref="bdcd2bc8e6792d0208435552579e48fb" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#bdcd2bc8e6792d0208435552579e48fb">m_useVertexColors</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should per-vertex colors be used? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95b0981e8b7313b2b17250978ce94944"></a><!-- doxytag: member="cGenericObject::m_triangleMode" ref="95b0981e8b7313b2b17250978ce94944" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#95b0981e8b7313b2b17250978ce94944">m_triangleMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The polygon rendering mode (GL_FILL or GL_LINE). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#ba5b3dc1ac539c9294210eccaeb95b37">m_useTransparency</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#4fd3077638218224ebc3ceec6532d44a">m_useMultipassTransparency</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#3eb41ef79679ab4396861194540479ac">m_cullingEnabled</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d438180f73d505409651e7c1d8638c8"></a><!-- doxytag: member="cGenericObject::m_collisionDetector" ref="1d438180f73d505409651e7c1d8638c8" args="" -->
<a class="el" href="classc_generic_collision.html">cGenericCollision</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#1d438180f73d505409651e7c1d8638c8">m_collisionDetector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The collision detector used to test for contact with this object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4307d3f5fce5146815e37778316376c3"></a><!-- doxytag: member="cGenericObject::m_frameGL" ref="4307d3f5fce5146815e37778316376c3" args="" -->
<a class="el" href="structc_matrix_g_l.html">cMatrixGL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_generic_object.html#4307d3f5fce5146815e37778316376c3">m_frameGL</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OpenGL matrix describing my position and orientation transformation. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class is the root of basically every render-able object in CHAI. It defines a reference frame (position and rotation) and virtual methods for rendering, which are overloaded by useful subclasses. <br>
. 
<p>
This class also defines basic methods for maintaining a scene graph, and propagating rendering passes and reference frame changes through a hierarchy of cGenericObjects. <br>
<p>
Besides subclassing, a useful way to extend <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a> is to store custom data in the m_tag and m_userData member fields, which are not used by CHAI. <br>
<p>
The most important methods to look at here are probably the virtual methods, which are listed last in <a class="el" href="_c_generic_object_8h.html" title=" Scenegraph    Base Class.">CGenericObject.h</a>. These methods will be called on each <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a> as operations propagate through the scene graph. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="587289693b38360ecc66684ec94c9209"></a><!-- doxytag: member="cGenericObject::~cGenericObject" ref="587289693b38360ecc66684ec94c9209" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cGenericObject::~cGenericObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>. 
<p>
Destructor of <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>. This function deletes all children starting from this point in the scene graph, so if you have objects that shouldn't be deleted, be sure to remove them from the scene graph before deleting their parents. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="84e3f5d5cd786a987c77ed19eed4c054"></a><!-- doxytag: member="cGenericObject::addChild" ref="84e3f5d5cd786a987c77ed19eed4c054" args="(cGenericObject *a_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::addChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an object to my list of children. 
<p>
Adds an object to the scene graph below this object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object to be added to children list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6be6f5bd0b76c89dd5d5f995b7392554"></a><!-- doxytag: member="cGenericObject::addEffect" ref="6be6f5bd0b76c89dd5d5f995b7392554" args="(cGenericEffect *a_newEffect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::addEffect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_effect.html">cGenericEffect</a> *&nbsp;</td>
          <td class="paramname"> <em>a_effect</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add an effect. 
<p>
Adds a haptic effect to the current object<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_effect</em>&nbsp;</td><td>Effect to be added to effects list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d7204c3654f82aa86599befff4b23aae"></a><!-- doxytag: member="cGenericObject::adjustCollisionSegment" ref="d7204c3654f82aa86599befff4b23aae" args="(cVector3d &amp;a_segmentPointA, cVector3d &amp;a_segmentPointAadjusted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::adjustCollisionSegment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointAadjusted</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjust collision segment for dynamic objects. 
<p>
Adjust the given segment such that it tests for intersection of the ray with objects at their previous positions at the last haptic loop so that collision detection will work in a dynamic environment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointA</em>&nbsp;</td><td>Start point of segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointAadjusted</em>&nbsp;</td><td>Same segment, adjusted to be in local space. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="152b67a212d8f359ec7a24d2c8be7a33"></a><!-- doxytag: member="cGenericObject::computeBoundaryBox" ref="152b67a212d8f359ec7a24d2c8be7a33" args="(const bool a_includeChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::computeBoundaryBox           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Re-compute this object's bounding box, optionally forcing it to bound child objects. 
<p>
Compute the bounding box of this object and (optionally) its children. <br>
<p>
If parameter <em>a_includeChildren</em> is set to <b>true</b> then each object's bounding box covers its own volume and the volume of its children. <br>
<p>
Note that regardless of this parameter's value, this operation propagates down the scene graph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If <b>true</b>, then children are included. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="47ed11f450db33671dbf27f12ffe1bcc"></a><!-- doxytag: member="cGenericObject::computeCollisionDetection" ref="47ed11f450db33671dbf27f12ffe1bcc" args="(cVector3d &amp;a_segmentPointA, cVector3d &amp;a_segmentPointB, cCollisionRecorder &amp;a_recorder, cCollisionSettings &amp;a_settings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::computeCollisionDetection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_collision_recorder.html">cCollisionRecorder</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_recorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_collision_settings.html">cCollisionSettings</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_settings</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute collision detection using collision trees. 
<p>
Determine whether the given segment intersects a triangle in this object (or any of its descendants). The segment is described by a start point <em>a_segmentPointA</em> and end point <em>a_segmentPointB</em>. Collision detection functions of all children of this object are called, which recursively call the collision detection functions for all of this object's descendants. If there is more than one collision, the one closest to a_segmentPointA is the one returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointA</em>&nbsp;</td><td>Start point of segment. Value may be changed if returned collision is with a moving object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointB</em>&nbsp;</td><td>End point of segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_recorder</em>&nbsp;</td><td>Stores all collision events. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_settings</em>&nbsp;</td><td>Contains collision settings information. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classc_world.html#8e8e45fae54994b52170b016a00f0252">cWorld</a>.</p>

</div>
</div><p>
<a class="anchor" name="af669adcf2a807bc30b5298b6985f24f"></a><!-- doxytag: member="cGenericObject::computeGlobalCurrentObjectOnly" ref="af669adcf2a807bc30b5298b6985f24f" args="(const bool a_frameOnly=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::computeGlobalCurrentObjectOnly           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_frameOnly</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the global position and rotation of current object only. 
<p>
Compute globalPos and globalRot for this object only, by recursively climbing up the scene graph tree until the root is reached.<p>
If <em>a_frameOnly</em> is set to <b>false</b>, additional global positions such as vertex positions are computed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_frameOnly</em>&nbsp;</td><td>If <b>true</b> then only the global frame is computed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab21f63a5cf247f607158ca1e7422617"></a><!-- doxytag: member="cGenericObject::computeGlobalPositions" ref="ab21f63a5cf247f607158ca1e7422617" args="(const bool a_frameOnly=true, const cVector3d &amp;a_globalPos=cVector3d(0.0, 0.0, 0.0), const cMatrix3d &amp;a_globalRot=cIdentity3d())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::computeGlobalPositions           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_frameOnly</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_globalPos</em> = <code><a class="el" href="structc_vector3d.html">cVector3d</a>(0.0,&nbsp;0.0,&nbsp;0.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_globalRot</em> = <code>cIdentity3d()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the global position and rotation of this object and its children. 
<p>
Compute globalPos and globalRot given the localPos and localRot of this object and its parents. Optionally propagates to children. <br>
<p>
If <em>a_frameOnly</em> is set to <b>false</b>, additional global positions such as vertex positions are computed (which can be time-consuming). <br>
<p>
Call this method any time you've moved an object and will need to access to globalPos and globalRot in this object or its children. For performance reasons, these values are not kept up-to-date by default, since almost all operations use local positions and rotations.?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_frameOnly</em>&nbsp;</td><td>If <b>true</b> then only the global frame is computed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_globalPos</em>&nbsp;</td><td>Global position of my parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_globalRot</em>&nbsp;</td><td>Global rotation matrix of my parent. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="473fcf59972cb7fa9c0d4eef29317c4a"></a><!-- doxytag: member="cGenericObject::computeInteractions" ref="473fcf59972cb7fa9c0d4eef29317c4a" args="(const cVector3d &amp;a_toolPos, const cVector3d &amp;a_toolVel, const unsigned int a_IDN, cInteractionRecorder &amp;a_interactions, cInteractionSettings &amp;a_interactionSettings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc_vector3d.html">cVector3d</a> cGenericObject::computeInteractions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_toolPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_toolVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_IDN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_interaction_recorder.html">cInteractionRecorder</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_interactions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_interaction_settings.html">cInteractionSettings</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_interactionSettings</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Descend through child objects to compute interactions for all <a class="el" href="classc_generic_effect.html" title="cGenericEffect provides a base class to program haptic effects (force models) when...">cGenericEffect</a> classes defined for each object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_toolPos</em>&nbsp;</td><td>Current position of tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_toolVel</em>&nbsp;</td><td>Current position of tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_IDN</em>&nbsp;</td><td>Identification number of the force algorithm. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_interactions</em>&nbsp;</td><td>List of recorded interactions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_interactionSettings</em>&nbsp;</td><td>Settings of the interaction recorder. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return resulting interaction forces. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f80fcd6a2dd14d167b82b7cbda9a43dd"></a><!-- doxytag: member="cGenericObject::computeLocalInteraction" ref="f80fcd6a2dd14d167b82b7cbda9a43dd" args="(const cVector3d &amp;a_toolPos, const cVector3d &amp;a_toolVel, const unsigned int a_IDN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::computeLocalInteraction           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_toolPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_toolVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_IDN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the geometric relationship between the tool and the current object. 
<p>
From the position of the tool, search for the nearest point located at the surface of the current object. Decide if the point is located inside or outside of the object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_toolPos</em>&nbsp;</td><td>Position of the tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_toolVel</em>&nbsp;</td><td>Velocity of the tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_IDN</em>&nbsp;</td><td>Identification number of the force algorithm. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classc_shape_line.html#6e6afb969106c3bf911ca0c5be6c54a7">cShapeLine</a>, <a class="el" href="classc_shape_sphere.html#7ad1ccb0d37f2bfdda31c06c366744d4">cShapeSphere</a>, and <a class="el" href="classc_shape_torus.html#25ae74d35381f54674bab8181ffa6668">cShapeTorus</a>.</p>

</div>
</div><p>
<a class="anchor" name="d54d4284c0ca71d2e199080bc3559878"></a><!-- doxytag: member="cGenericObject::containsChild" ref="d54d4284c0ca71d2e199080bc3559878" args="(cGenericObject *a_object, bool a_includeChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::containsChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this object have the specified object as a child? 
<p>
Does this object have the specified object as a child?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>Should we also search this object's descendants? </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a1552a230244d2119043026e03aef8f2"></a><!-- doxytag: member="cGenericObject::deleteAllChildren" ref="a1552a230244d2119043026e03aef8f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::deleteAllChildren           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear and delete all objects from my list of children. 
<p>
Delete and clear all objects from my list of children. 
</div>
</div><p>
<a class="anchor" name="b612f2a2121062bd70b1096bc51a6895"></a><!-- doxytag: member="cGenericObject::deleteChild" ref="b612f2a2121062bd70b1096bc51a6895" args="(cGenericObject *a_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::deleteChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an object from my list of children and delete it. 
<p>
Removes an object from my list of children, and deletes the child object from memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object to be removed from my list of children and deleted. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns <b>true</b> if the specified object was found on my list of children. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e923e09ba8708ecc49f423f0ef68fba8"></a><!-- doxytag: member="cGenericObject::deleteCollisionDetector" ref="e923e09ba8708ecc49f423f0ef68fba8" args="(const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::deleteCollisionDetector           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete any existing collision detector and set the current cd to null (no collisions). 
<p>
Delete any existing collision detector and set the current cd to null. It's fine for an object to have a null collision detector (that's the default for a new object, in fact), it just means that no collisions will be found.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If true, all my children's cd's are also deleted. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="58001a089d78289dde9adfc2403a6a62"></a><!-- doxytag: member="cGenericObject::enumerateChildren" ref="58001a089d78289dde9adfc2403a6a62" args="(std::list&lt; cGenericObject * &gt; &amp;a_childList, bool a_includeCurrentObject=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::enumerateChildren           </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="classc_generic_object.html">cGenericObject</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a_childList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeCurrentObject</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill this list with all of my descendants. 
<p>
Fill this list with all of my descendants. The current object is optionally included in this list. Does not clear the list before appending to it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_childList</em>&nbsp;</td><td>The list to write our enumerated results to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeCurrentObject</em>&nbsp;</td><td>Should I include myself on the list? </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ca3d6fc97084c2ab439d2486d98e23e6"></a><!-- doxytag: member="cGenericObject::finalize" ref="ca3d6fc97084c2ab439d2486d98e23e6" args="(const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::finalize           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function tells children that you're not going to change their contents any more. 
<p>
This call tells an object that you're not going to modify him any more. For example, a mesh-like object might optimize his vertex arrangement when he gets this call. Always optional; just for performance...<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="746f4083ff824c30a246cd01c17893a1"></a><!-- doxytag: member="cGenericObject::getNumDescendants" ref="746f4083ff824c30a246cd01c17893a1" args="(bool a_includeCurrentObject=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cGenericObject::getNumDescendants           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeCurrentObject</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return my total number of descendants, optionally including this object. 
<p>
Return my total number of descendants, optionally including this object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_includeCurrentObject</em>&nbsp;</td><td>Should I include myself in the count? </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of descendants found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bceaa39ca365c7092d4b3932665439d8"></a><!-- doxytag: member="cGenericObject::onDisplayReset" ref="bceaa39ca365c7092d4b3932665439d8" args="(const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::onDisplayReset           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function should get called when it's necessary to re-initialize the OpenGL context. 
<p>
Users should call this function when it's necessary to re-initialize the OpenGL context; e.g. re-initialize textures and display lists. Subclasses should perform whatever re-initialization they need to do. <br>
<p>
Note that this is not an event CHAI can easily detect, so it's up to the application-writer to call this function on the root of the scenegraph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classc_camera.html#855eb0c3bfea98decf9b2bda0bf4c1ca">cCamera</a>, <a class="el" href="classc_mesh.html#7fc10e529990bc678f026a9f7d1607e2">cMesh</a>, and <a class="el" href="classc_world.html#c9bbc08506ccede9d5213449c33273a3">cWorld</a>.</p>

</div>
</div><p>
<a class="anchor" name="90e5033f96dc1e891cac79e5e56e1424"></a><!-- doxytag: member="cGenericObject::removeChild" ref="90e5033f96dc1e891cac79e5e56e1424" args="(cGenericObject *a_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::removeChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an object from my list of children, without deleting it. 
<p>
Removes an object from my list of children, without deleting the child object from memory.<p>
This method assigns the child object's parent point to null, so if you're moving someone around in your scene graph, make sure you call this function _before_ you add the child to another node in the scene graph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_object</em>&nbsp;</td><td>Object to be removed from my list of children. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns <b>true</b> if the specified object was found on my list of children </dd></dl>

</div>
</div><p>
<a class="anchor" name="7eb87a0e7dd896f081854e693e4f60d9"></a><!-- doxytag: member="cGenericObject::render" ref="7eb87a0e7dd896f081854e693e4f60d9" args="(const int a_renderMode=CHAI_RENDER_MODE_RENDER_ALL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::render           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_renderMode</em> = <code>CHAI_RENDER_MODE_RENDER_ALL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render this object in OpenGL. 
<p>
Render this object. Subclasses will generally override this method. This is called from renderSceneGraph, which subclasses generally do not need to override. <br>
<p>
The a_renderMode parameter is used to allow multiple rendering passes, and takes one of the following values: <br>
<p>
CHAI_RENDER_MODE_NON_TRANSPARENT_ONLY=0, <br>
 CHAI_RENDER_MODE_TRANSPARENT_BACK_ONLY, <br>
 CHAI_RENDER_MODE_TRANSPARENT_FRONT_ONLY, <br>
 CHAI_RENDER_MODE_RENDER_ALL <br>
<p>
If you have multipass transparency disabled (see <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a>), your objects will only be rendered once per frame, with a_renderMode set to CHAI_RENDER_MODE_RENDER_ALL. This is the default, and unless you enable multipass transparency, you don't ever need to care about a_renderMode. <br>
<p>
A word on OpenGL conventions: <br>
<p>
CHAI does not re-initialize the OpenGL state at every rendering pass. The only OpenGL state variables that CHAI sets explicitly in a typical rendering pass are: <br>
<p>
lighting is enabled (<a class="el" href="classc_world.html" title="cWorld defines the typical root of the CHAI scene graph. It stores lights, allocates...">cWorld</a>) <br>
 depth-testing is enabled (<a class="el" href="classc_world.html" title="cWorld defines the typical root of the CHAI scene graph. It stores lights, allocates...">cWorld</a>) <br>
 glColorMaterial is enabled and set to GL_AMBIENT_AND_DIFFUSE/GL_FRONT_AND_BACK (<a class="el" href="classc_world.html" title="cWorld defines the typical root of the CHAI scene graph. It stores lights, allocates...">cWorld</a>) <br>
 a perspective projection matrix is set up (<a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a>) <br>
<p>
This adherence to the defaults is nice because it lets an application change an important piece of state globally and not worry about it getting changed by CHAI objects. <br>
<p>
It is expected that objects will "clean up after themselves" if they change any rendering state besides:<p>
color (glColor) <br>
 material properties (glMaterial) <br>
 normals (glNormal) <br>
<p>
For example, if my object changes the rendering color, I don't need to set it back before returning, but if my object turns on vertex buffering, I should turn it off before returning. Consequently if I care about the current color, I should set it up in my own <a class="el" href="classc_generic_object.html#7eb87a0e7dd896f081854e693e4f60d9" title="Render this object in OpenGL.">render()</a> function, because I shouldn't count on it being meaningful when my <a class="el" href="classc_generic_object.html#7eb87a0e7dd896f081854e693e4f60d9" title="Render this object in OpenGL.">render()</a> function is called. <br>
<p>
Necessary exceptions to these conventions include: <br>
<p>
<a class="el" href="classc_light.html" title="cLight describes an OpenGL light source, generally rendered by a cWorld object, which...">cLight</a> will change the lighting state for his assigned GL_LIGHT <br>
 <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a> sets up relevant transformation matrices <br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_renderMode</em>&nbsp;</td><td>Rendering mode; see above </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classc_mesh.html#dd34043a0d263f2353c79985c9ca4098">cMesh</a>, <a class="el" href="classc_shape_line.html#a1ab57720cf3406c5b06e8b44f678ca2">cShapeLine</a>, <a class="el" href="classc_shape_sphere.html#ea8623107c526cb97a2ca3c4dd3d9aa4">cShapeSphere</a>, <a class="el" href="classc_shape_torus.html#8a56ab6e6f76a42e2fc7898c424e8e4d">cShapeTorus</a>, <a class="el" href="classc_world.html#dcc79277c1b0681354a5592c4c14a4af">cWorld</a>, <a class="el" href="classc_generic3dof_pointer.html#a9cf38d952ea72a75b036d1178c100ad">cGeneric3dofPointer</a>, <a class="el" href="classc_generic_tool.html#186f10f08692ee8638473242ecbd00a7">cGenericTool</a>, <a class="el" href="classc_label.html#4de554c6c0b050f74aaf1feb8a434449">cLabel</a>, <a class="el" href="classc_g_e_l_mesh.html#6f099ca6f940be66a08502cf879f17b1">cGELMesh</a>, and <a class="el" href="classc_o_d_e_generic_body.html#75098147b6fd0382b5a337123b9360de">cODEGenericBody</a>.</p>

</div>
</div><p>
<a class="anchor" name="f5189d2e6a0456c2d5f257ca8bdf360a"></a><!-- doxytag: member="cGenericObject::renderSceneGraph" ref="f5189d2e6a0456c2d5f257ca8bdf360a" args="(const int a_renderMode=CHAI_RENDER_MODE_RENDER_ALL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::renderSceneGraph           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_renderMode</em> = <code>CHAI_RENDER_MODE_RENDER_ALL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render the entire scene graph, starting from this object. 
<p>
Render the scene graph starting at this object. This method is called for each object and optionally renders the object itself, its reference frame and the collision and/or scenegraph trees. <br>
<p>
The object itself is rendered by calling <a class="el" href="classc_generic_object.html#7eb87a0e7dd896f081854e693e4f60d9" title="Render this object in OpenGL.">render()</a>, which should be defined for each subclass that has a graphical representation. renderSceneGraph does not generally need to be over-ridden in subclasses. <br>
<p>
The a_renderMode parameter is used to allow multiple rendering passes, and takes one of the following values: <br>
<p>
CHAI_RENDER_MODE_NON_TRANSPARENT_ONLY=0, <br>
 CHAI_RENDER_MODE_TRANSPARENT_BACK_ONLY, <br>
 CHAI_RENDER_MODE_TRANSPARENT_FRONT_ONLY, <br>
 CHAI_RENDER_MODE_RENDER_ALL <br>
<p>
If you have multipass transparency disabled (see <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a>), your objects will only be rendered once per frame, with a_renderMode set to CHAI_RENDER_MODE_RENDER_ALL. This is the default, and unless you enable multipass transparency, you don't ever need to care about a_renderMode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_renderMode</em>&nbsp;</td><td>Rendering mode. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9b82697b12cefa4a9601a45e055f8cb"></a><!-- doxytag: member="cGenericObject::rotate" ref="f9b82697b12cefa4a9601a45e055f8cb" args="(const cVector3d &amp;a_axis, const double a_angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::rotate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate this object around axis a_axis by angle a_angle (radians). 
<p>
Rotate this object around axis a_axis by angle a_angle (radians). a_axis is not normalized, so unless you know what you're doing, normalize your axis before supplying it to this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_axis</em>&nbsp;</td><td>Rotation axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_angle</em>&nbsp;</td><td>Rotation angle in radians. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bba165a0395766782e2dbe7735efe8a9"></a><!-- doxytag: member="cGenericObject::rotate" ref="bba165a0395766782e2dbe7735efe8a9" args="(const cMatrix3d &amp;a_rotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::rotate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_rotation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate this object by multiplying with a specified rotation matrix. 
<p>
Rotate this object by multiplying with a specified rotation matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_rotation</em>&nbsp;</td><td>Rotation matrix. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8bdcfa16951b6da2f8c6f0b95d2d9500"></a><!-- doxytag: member="cGenericObject::scale" ref="8bdcfa16951b6da2f8c6f0b95d2d9500" args="(const cVector3d &amp;a_scaleFactors, const bool a_includeChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::scale           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_scaleFactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-uniform scale. 
<p>
Non-uniform scale, optionally include children. Not necessarily implemented in all subclasses. Does nothing at the <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a> level; subclasses should scale themselves, then call the superclass method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_scaleFactors</em>&nbsp;</td><td>Possibly non-uniform scale factors. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If <b>true</b>, this message is passed to children. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9be8abb917b1f84e5196c0213aca1617"></a><!-- doxytag: member="cGenericObject::scale" ref="9be8abb917b1f84e5196c0213aca1617" args="(const double &amp;a_scaleFactor, const bool a_includeChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::scale           </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&nbsp;</td>
          <td class="paramname"> <em>a_scaleFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scale this object by a_scaleFactor (uniform scale). 
<p>
Uniform scale, optionally include children. Not necessarily implemented in all subclasses. Does nothing at the <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a> level. Subclasses should scale themselves, then call the superclass method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_scaleFactor</em>&nbsp;</td><td>Scale factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If <b>true</b>, this message is passed to children. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="01f651983f2be2211fbb97b2e1c40f3b"></a><!-- doxytag: member="cGenericObject::setAsGhost" ref="01f651983f2be2211fbb97b2e1c40f3b" args="(bool a_ghostStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setAsGhost           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_ghostStatus</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes this object a ghost node. 
<p>
It can be sometimes useful to add an object twice in a scenegraph to create for instance a reflexion of a model over a ground. In these cases there only one model for which all the interactions should be computed. The second one is only there for display purposes. By enabling the ghost status, we disable all collision detection, force interaction further down the scene graph. An example of this feature can be found in the example "ODE-cube". 
</div>
</div><p>
<a class="anchor" name="36189f1d90cb10cbddb429d5789eef9f"></a><!-- doxytag: member="cGenericObject::setBoxColor" ref="36189f1d90cb10cbddb429d5789eef9f" args="(const cColorf &amp;a_boxColor, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setBoxColor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_colorf.html">cColorf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_boxColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the color of boundary box for this object, optionally propagating the change to children. 
<p>
Set the color of the graphic representation of the boundary boundary box of this object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_boxColor</em>&nbsp;</td><td>Color of boundary box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="22abb35355c5be8622be3cac2e6fb510"></a><!-- doxytag: member="cGenericObject::setCollisionDetectorProperties" ref="22abb35355c5be8622be3cac2e6fb510" args="(unsigned int a_displayDepth, cColorf &amp;a_color, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setCollisionDetectorProperties           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_displayDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_colorf.html">cColorf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set collision rendering properties. 
<p>
Set the rendering properties for the graphic representation of collision detection tree at this node. <br>
<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_color</em>&nbsp;</td><td>Color used to render collision detector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_displayDepth</em>&nbsp;</td><td>Indicated which depth of collision tree needs to be displayed (see <a class="el" href="classc_generic_collision.html" title="cGenericCollision is an abstract class for collision-detection algorithms for meshes...">cGenericCollision</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b77f1daab7169e2663f2c2b32135fbb5"></a><!-- doxytag: member="cGenericObject::setExternalParent" ref="b77f1daab7169e2663f2c2b32135fbb5" args="(cGenericType *a_externalParent, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setExternalParent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_type.html">cGenericType</a> *&nbsp;</td>
          <td class="paramname"> <em>a_externalParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a pointer to an external parent of the current object. Optionally propagating the change to children. 
<p>
Sets a pointer to an external parent of the current object. Optionally propagating the change to children. A pointer to an external parent located outside of the scenegraph. This parameter can typically be used if you want to attach an generic object to some other object outside of CHAI3D of to an external representation such as a dynamics engine model. See the ODE examples to understand how a generic object can be attached to an ODE object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_externalParent</em>&nbsp;</td><td>External parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, this message is passed to children. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c43081628c7ae8577dcb270983eea2e6"></a><!-- doxytag: member="cGenericObject::setFrameSize" ref="c43081628c7ae8577dcb270983eea2e6" args="(const double a_size=1.0, const double a_thickness=1.0, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cGenericObject::setFrameSize           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_size</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_thickness</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the size of the rendered reference frame, optionally propagating the change to children. 
<p>
Set the display size of the arrows representing my reference frame. The size corresponds to the length of each displayed axis (X-Y-Z). <br>
<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_size</em>&nbsp;</td><td>Length of graphical representation of frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_thickness</em>&nbsp;</td><td>Thickness of graphical representation of frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d58d996e3ff702f26f80a14580982e05"></a><!-- doxytag: member="cGenericObject::setFriction" ref="d58d996e3ff702f26f80a14580982e05" args="(double a_staticFriction, double a_dynamicFriction, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setFriction           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a_staticFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a_dynamicFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the static and dynamic friction for this mesh, possibly recursively affecting children. 
<p>
Set the static and dynamic friction for this mesh, possibly recursively affecting children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_staticFriction</em>&nbsp;</td><td>The static friction to apply to this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_dynamicFriction</em>&nbsp;</td><td>The dynamic friction to apply to this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6c9067771330437a4906eb90e45db334"></a><!-- doxytag: member="cGenericObject::setHapticEnabled" ref="6c9067771330437a4906eb90e45db334" args="(const bool a_hapticEnabled, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setHapticEnabled           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_hapticEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow this object to be felt (when visible), optionally propagating the change to children. 
<p>
Allow or disallow the object to be felt (when visible). <br>
<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_hapticEnabled</em>&nbsp;</td><td>If <b>true</b> object can be felt when visible. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="27083888fdfd8e055131f3842967d7f0"></a><!-- doxytag: member="cGenericObject::setMaterial" ref="27083888fdfd8e055131f3842967d7f0" args="(cMaterial &amp;a_mat, const bool a_affectChildren=false, const bool a_applyPhysicalParmetersOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setMaterial           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc_material.html">cMaterial</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_applyPhysicalParmetersOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the material for this mesh, and optionally pass it on to my children. 
<p>
Set the current material for this mesh, possibly recursively affecting children. If parameter a_applyPhysicalParmetersOnly is set to <b>true</b> then only the physical properties are modified. This is extremely useful if the user loads a 3d object file into a mesh and then applies some haptic properties which are also defined in the <a class="el" href="structc_material.html" title="cMaterial provide a description for handling OpenGL graphic material properties....">cMaterial</a> class. <br>
<p>
Note that this does not affect whether material rendering is enabled; it sets the maetrial that will be rendered _if_ material rendering is enabled. Call useMaterial to enable / disable material rendering.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_mat</em>&nbsp;</td><td>The material to apply to this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_applyPhysicalParmetersOnly</em>&nbsp;</td><td>If <b>true</b>, then only physical properties are applied </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8a1cce0f5d34a968da81bcb54524e8b1"></a><!-- doxytag: member="cGenericObject::setName" ref="8a1cce0f5d34a968da81bcb54524e8b1" args="(const char *a_name, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>a_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the name for this object and - optionally - for my children. 
<p>
Set the name for this object and - optionally - for my children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_name</em>&nbsp;</td><td>The name we'll assign to this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3d1b3334e5dcb92ff585694f1b18d7f7"></a><!-- doxytag: member="cGenericObject::setShowBox" ref="3d1b3334e5dcb92ff585694f1b18d7f7" args="(const bool iShowBox, const bool iAffectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShowBox           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide the boundary box for this object, optionally propagating the change to children. 
<p>
Show or hide the graphic representation of the boundary box of this object. <br>
<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showBox</em>&nbsp;</td><td>If <b>true</b>, boundary box is displayed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c229037462e3526453d37ae7136ea93a"></a><!-- doxytag: member="cGenericObject::setShowCollisionTree" ref="c229037462e3526453d37ae7136ea93a" args="(const bool a_showCollisionTree, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShowCollisionTree           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showCollisionTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide the collision tree for this object, optionally propagating the change to children. 
<p>
Show or hide the graphic representation of the collision tree at this node. <br>
<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showCollisionTree</em>&nbsp;</td><td>If <b>true</b>, small normals are rendered graphicaly. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="089981024cc3376c7b00c3c6df9d70f3"></a><!-- doxytag: member="cGenericObject::setShowEnabled" ref="089981024cc3376c7b00c3c6df9d70f3" args="(const bool a_show, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShowEnabled           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_show</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide this object, optionally propagating the change to children. 
<p>
Show or hide this object. <br>
<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_show</em>&nbsp;</td><td>If <b>true</b> object shape is visible. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="645192ff03d772d141a2e391fe355910"></a><!-- doxytag: member="cGenericObject::setShowFrame" ref="645192ff03d772d141a2e391fe355910" args="(const bool a_showFrame, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShowFrame           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide the reference frame arrows for this object, optionally propagating the change to children. 
<p>
Show or hide the set of arrows that represent this object's reference frame.<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showFrame</em>&nbsp;</td><td>If <b>true</b> then frame is displayed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="363edb61b70cd06722a7b9d9594da1da"></a><!-- doxytag: member="cGenericObject::setShowTree" ref="363edb61b70cd06722a7b9d9594da1da" args="(const bool a_showTree, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setShowTree           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide the child/parent tree, optionally propagating the change to children. 
<p>
Show or hide the graphic representation of the scene graph at this node. <br>
<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showTree</em>&nbsp;</td><td>If <b>true</b> then tree is displayed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7d9e7359d3709477e58e5d22c65bb23d"></a><!-- doxytag: member="cGenericObject::setStiffness" ref="7d9e7359d3709477e58e5d22c65bb23d" args="(double a_stiffness, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setStiffness           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a_stiffness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the haptic stiffness, possibly recursively affecting children. 
<p>
Set the haptic stiffness for this mesh, possibly recursively affecting children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_stiffness</em>&nbsp;</td><td>The stiffness to apply to this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c49958287cc1bd7fbd28b1101445e839"></a><!-- doxytag: member="cGenericObject::setSuperParent" ref="c49958287cc1bd7fbd28b1101445e839" args="(cGenericObject *a_superParent, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setSuperParent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>a_superParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the super parent of the current object. Optionally propagating the change to children. 
<p>
Sets the super parent of the current object. Optionally propagating the change to children. A super parent points to another object generally located higher up in the scene graph. When a mesh is created, the super parent of its children will generally point towards the root of the mesh. This parameter is automatically set by the 3D object file loader.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_superParent</em>&nbsp;</td><td>Super parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, this message is passed to children. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="001853c55875d15fc535f6806ac0b47b"></a><!-- doxytag: member="cGenericObject::setTag" ref="001853c55875d15fc535f6806ac0b47b" args="(const int a_tag, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setTag           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the tag for this object and - optionally - for my children. 
<p>
Set the tag for this object and - optionally - for my children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_tag</em>&nbsp;</td><td>The tag we'll assign to this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b9115557e2b23eb7f050b42fd610c19"></a><!-- doxytag: member="cGenericObject::setTexture" ref="6b9115557e2b23eb7f050b42fd610c19" args="(cTexture2D *a_texture, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setTexture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_texture2_d.html">cTexture2D</a> *&nbsp;</td>
          <td class="paramname"> <em>a_texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set my texture, possibly recursively affecting children. 
<p>
Set the current texture for this mesh, possibly recursively affecting children. <br>
<p>
Note that this does not affect whether texturing is enabled; it sets the texture that will be rendered _if_ texturing is enabled. Call useTexture to enable / disable texturing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_texture</em>&nbsp;</td><td>The texture to apply to this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b7c8b442fc3acc50374df2f0f678e696"></a><!-- doxytag: member="cGenericObject::setTransparencyLevel" ref="b7c8b442fc3acc50374df2f0f678e696" args="(const float a_level, const bool a_applyToTextures=false, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setTransparencyLevel           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_applyToTextures</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the alpha value at each vertex and in all of my material colors. 
<p>
Set the alpha value at each vertex, in all of my material colors, optionally propagating the operation to my children. <br>
<p>
Using the 'apply to textures' option causes the actual texture alpha values to be over-written in my texture, if it exists. <br>
<p>
[Editor's note: the 'apply to textures' option is not currently enabled, since (a) it's a silly way to control transparency and (b) not all textures have an alpha channel.]<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_level</em>&nbsp;</td><td>Level of transparency ranging from 0.0 to 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_applyToTextures</em>&nbsp;</td><td>If <b>true</b>, then apply changes to texture. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children also modified. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classc_mesh.html#6f1b5d31fc08c0e4a1fce2e1c01c40c6">cMesh</a>.</p>

</div>
</div><p>
<a class="anchor" name="86c7c6188ea7bb40691081ce65b61123"></a><!-- doxytag: member="cGenericObject::setTransparencyRenderMode" ref="86c7c6188ea7bb40691081ce65b61123" args="(const bool a_useMultipassTransparency, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setTransparencyRenderMode           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_useMultipassTransparency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify whether this mesh should use multipass transparency (see <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a>). 
<p>
Specify whether transparent rendering should use two passes (looks better) or one pass (runs faster). See <a class="el" href="classc_camera.html" title="cCamera describes a virtual Camera located inside the world. Its job in life is to...">cCamera</a> for more information about multipass transparency.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_useMultipassTransparency</em>&nbsp;</td><td>If <b>true</b>, this mesh uses multipass rendering. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec8f42b031fb0140633b5cb73e16094b"></a><!-- doxytag: member="cGenericObject::setTreeColor" ref="ec8f42b031fb0140633b5cb73e16094b" args="(const cColorf &amp;a_treeColor, const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setTreeColor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_colorf.html">cColorf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_treeColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the tree color, optionally propagating the change to children. 
<p>
Set the color of the graphic representation of the scene graph at this node. <br>
<p>
If <em>a_affectChildren</em> is set to <b>true</b> then all children are updated with the new value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_treeColor</em>&nbsp;</td><td>Color of tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44fd98520ccf092e2ba5299ddec2c248"></a><!-- doxytag: member="cGenericObject::setUseCulling" ref="44fd98520ccf092e2ba5299ddec2c248" args="(const bool a_useCulling, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setUseCulling           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_useCulling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disabling face-culling, optionally propagating the operation to my children. 
<p>
Enables or disables backface culling (rendering in GL is much faster with culling on).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_useCulling</em>&nbsp;</td><td>If <b>true</b>, backfaces are culled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, this operation is propagated to my children. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="27ca76ab6660297f134d39f796b967d2"></a><!-- doxytag: member="cGenericObject::setUseMaterial" ref="27ca76ab6660297f134d39f796b967d2" args="(const bool a_useMaterial, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setUseMaterial           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_useMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable the use of material properties, optionally propagating the operation to my children. 
<p>
Enable or disable the use of material properties.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_useMaterial</em>&nbsp;</td><td>If <b>true</b>, then material properties are used for rendering. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af6da87dec3f13c00fd338ea9af1c9fc"></a><!-- doxytag: member="cGenericObject::setUserData" ref="af6da87dec3f13c00fd338ea9af1c9fc" args="(void *a_data, const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setUserData           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the m_userData pointer for this object and - optionally - for my children. 
<p>
Set the m_userData pointer for this object and - optionally - for my children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_data</em>&nbsp;</td><td>The pointer to which we will set m_userData </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates. through the scene graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e36467b7ef1d1d2c60933bfca3b30309"></a><!-- doxytag: member="cGenericObject::setUseTexture" ref="e36467b7ef1d1d2c60933bfca3b30309" args="(const bool a_useTexture, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setUseTexture           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_useTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable the use of texture-mapping, optionally propagating the operation to my children. 
<p>
Enable or disable texture-mapping, possibly recursively affecting children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_useTexture</em>&nbsp;</td><td>If <b>true</b>, then texture mapping is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9d463f2aa2d54ab5b56a9aa99b65807a"></a><!-- doxytag: member="cGenericObject::setUseTransparency" ref="9d463f2aa2d54ab5b56a9aa99b65807a" args="(const bool a_useTransparency, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setUseTransparency           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_useTransparency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable transparency (also see setTransparencyRenderMode)... turns the depth mask _off_! 
<p>
Specify whether transparency should be enabled. Note that this does not affect the transparency _mode_, which controls the use of simple transparency vs. multipass transparency.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_useTransparency</em>&nbsp;</td><td>If <b>true</b>, transparency is enabled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="54e26549e25f2f11c56ec2dbfc0a591a"></a><!-- doxytag: member="cGenericObject::setUseVertexColors" ref="54e26549e25f2f11c56ec2dbfc0a591a" args="(const bool a_useColors, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setUseVertexColors           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_useColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable the use of per-vertex colors, optionally propagating the operation to my children. 
<p>
Enable or disable the use of per-vertex color information of when rendering the mesh.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_useColors</em>&nbsp;</td><td>If <b>true</b>, then vertex color information is applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also modified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="42738805cabe3bd0f44f49b794ce0ef5"></a><!-- doxytag: member="cGenericObject::setWireMode" ref="42738805cabe3bd0f44f49b794ce0ef5" args="(const bool a_showWireMode, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::setWireMode           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_showWireMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable wireframe rendering, optionally propagating the operation to my children. 
<p>
Enable or disable wireframe rendering, optionally propagating the operation to my children.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showWireMode</em>&nbsp;</td><td>If <b>true</b>, wireframe mode is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92df52ff262a682849a1e572393ff9b4"></a><!-- doxytag: member="cGenericObject::translate" ref="92df52ff262a682849a1e572393ff9b4" args="(const double a_x, const double a_y, const double a_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::translate           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translate this object by a specified offset. 
<p>
Translate an object by a specified offset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_x</em>&nbsp;</td><td>Translation component X. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_y</em>&nbsp;</td><td>Translation component Y. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_z</em>&nbsp;</td><td>Translation component Z. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b08a1331c6217e833acf95466799962f"></a><!-- doxytag: member="cGenericObject::translate" ref="b08a1331c6217e833acf95466799962f" args="(const cVector3d &amp;a_translation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::translate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_translation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translate this object by a specified offset. 
<p>
Translate this object by a specified offset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_translation</em>&nbsp;</td><td>Translation offset. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c6bf258cebfd460192b3a1383266ea95"></a><!-- doxytag: member="cGenericObject::unfinalize" ref="c6bf258cebfd460192b3a1383266ea95" args="(const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenericObject::unfinalize           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function tells objects that you may modify their contents. 
<p>
This call tells an object that you may modify his contents. See <a class="el" href="classc_generic_object.html#ca3d6fc97084c2ab439d2486d98e23e6" title="This function tells children that you&#39;re not going to change their contents any...">finalize()</a> for more information.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, the operation propagates through the scene graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="3eb41ef79679ab4396861194540479ac"></a><!-- doxytag: member="cGenericObject::m_cullingEnabled" ref="3eb41ef79679ab4396861194540479ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classc_generic_object.html#3eb41ef79679ab4396861194540479ac">cGenericObject::m_cullingEnabled</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Should culling be used when rendering triangles? <br>
<p>
Note that this option only applies when multipass transparency is disabled or during the non-transparent rendering pass when multipass transparency is enabled... <br>
<p>
Also note that currently only back-faces are culled during non-transparent rendering; you can't cull front-faces. 
</div>
</div><p>
<a class="anchor" name="d751b0a72776192a9775dbbb0bd1f07a"></a><!-- doxytag: member="cGenericObject::m_externalParent" ref="d751b0a72776192a9775dbbb0bd1f07a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc_generic_type.html">cGenericType</a>* <a class="el" href="classc_generic_object.html#d751b0a72776192a9775dbbb0bd1f07a">cGenericObject::m_externalParent</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A pointer to an external parent located outside of the scenegraph. This parameter can typically be used if you want to attach an generic object to some other object outside of CHAI3D of to an external representation such as a dynamics engine model. See the ODE examples to understand how a generic object can be attached to an ODE object. 
</div>
</div><p>
<a class="anchor" name="a2eeb07fed010a22852eafa9bd030f62"></a><!-- doxytag: member="cGenericObject::m_superParent" ref="a2eeb07fed010a22852eafa9bd030f62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc_generic_object.html">cGenericObject</a>* <a class="el" href="classc_generic_object.html#a2eeb07fed010a22852eafa9bd030f62">cGenericObject::m_superParent</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A super parent points to another object generally located higher up in the scene graph. When a mesh is created, the super parent of its children will generally point towards the root of the mesh. This parameter is automatically set by the 3D object file loader. 
</div>
</div><p>
<a class="anchor" name="4fd3077638218224ebc3ceec6532d44a"></a><!-- doxytag: member="cGenericObject::m_useMultipassTransparency" ref="4fd3077638218224ebc3ceec6532d44a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classc_generic_object.html#4fd3077638218224ebc3ceec6532d44a">cGenericObject::m_useMultipassTransparency</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If true, multipass transparency is permitted for this mesh... this means that if the rendering camera is using multipass transparency, this mesh will render back and front faces separately. <br>
<p>
Note that m_useTransparency also has to be <b>true</b> for this variable to be meaningful. 
<p>Reimplemented in <a class="el" href="classc_camera.html#57e643247aa7dda4afc4adccf1593ece">cCamera</a>.</p>

</div>
</div><p>
<a class="anchor" name="ba5b3dc1ac539c9294210eccaeb95b37"></a><!-- doxytag: member="cGenericObject::m_useTransparency" ref="ba5b3dc1ac539c9294210eccaeb95b37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classc_generic_object.html#ba5b3dc1ac539c9294210eccaeb95b37">cGenericObject::m_useTransparency</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If true, transparency is enabled... this turns alpha on when the mesh is rendered, and - if multipass transparency is enabled in the rendering camera - uses the camera's multiple rendering passes to approximate back-to-front sorting via culling. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>D:/CHAI3D/build-2-0-0/2.0.0/win32/src/scenegraph/<a class="el" href="_c_generic_object_8h_source.html">CGenericObject.h</a><li>D:/CHAI3D/build-2-0-0/2.0.0/win32/src/scenegraph/CGenericObject.cpp</ul>
</div>
<font size=-2><br><hr><b>CHAI3D 2.0.0 documentation</b><br>Please address any questions to <a href="mailto:support@chai3d.org">support@chai3d.org</a><br>
	(C) 2003-2009 - <a href="http://www.chai3d.org">CHAI 3D</a><br>
	All Rights Reserved.
